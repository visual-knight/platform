// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateProject {
  count: Int!
}

type AggregateRefreshTokenList {
  count: Int!
}

type AggregateTest {
  count: Int!
}

type AggregateTestSession {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVariation {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Json

scalar Long

type Mutation {
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
  createRefreshTokenList(data: RefreshTokenListCreateInput!): RefreshTokenList!
  updateRefreshTokenList(data: RefreshTokenListUpdateInput!, where: RefreshTokenListWhereUniqueInput!): RefreshTokenList
  updateManyRefreshTokenLists(data: RefreshTokenListUpdateManyMutationInput!, where: RefreshTokenListWhereInput): BatchPayload!
  upsertRefreshTokenList(where: RefreshTokenListWhereUniqueInput!, create: RefreshTokenListCreateInput!, update: RefreshTokenListUpdateInput!): RefreshTokenList!
  deleteRefreshTokenList(where: RefreshTokenListWhereUniqueInput!): RefreshTokenList
  deleteManyRefreshTokenLists(where: RefreshTokenListWhereInput): BatchPayload!
  createTest(data: TestCreateInput!): Test!
  updateTest(data: TestUpdateInput!, where: TestWhereUniqueInput!): Test
  updateManyTests(data: TestUpdateManyMutationInput!, where: TestWhereInput): BatchPayload!
  upsertTest(where: TestWhereUniqueInput!, create: TestCreateInput!, update: TestUpdateInput!): Test!
  deleteTest(where: TestWhereUniqueInput!): Test
  deleteManyTests(where: TestWhereInput): BatchPayload!
  createTestSession(data: TestSessionCreateInput!): TestSession!
  updateTestSession(data: TestSessionUpdateInput!, where: TestSessionWhereUniqueInput!): TestSession
  updateManyTestSessions(data: TestSessionUpdateManyMutationInput!, where: TestSessionWhereInput): BatchPayload!
  upsertTestSession(where: TestSessionWhereUniqueInput!, create: TestSessionCreateInput!, update: TestSessionUpdateInput!): TestSession!
  deleteTestSession(where: TestSessionWhereUniqueInput!): TestSession
  deleteManyTestSessions(where: TestSessionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVariation(data: VariationCreateInput!): Variation!
  updateVariation(data: VariationUpdateInput!, where: VariationWhereUniqueInput!): Variation
  updateManyVariations(data: VariationUpdateManyMutationInput!, where: VariationWhereInput): BatchPayload!
  upsertVariation(where: VariationWhereUniqueInput!, create: VariationCreateInput!, update: VariationUpdateInput!): Variation!
  deleteVariation(where: VariationWhereUniqueInput!): Variation
  deleteManyVariations(where: VariationWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Project {
  id: ID!
  createdAt: DateTime!
  name: String!
  tests(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Test!]
  updatedAt: DateTime!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  description: String
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  id: ID
  name: String!
  tests: TestCreateManyWithoutProjectInput
  users: UserCreateManyWithoutProjectsInput
  description: String
}

input ProjectCreateManyWithoutUsersInput {
  create: [ProjectCreateWithoutUsersInput!]
  connect: [ProjectWhereUniqueInput!]
}

input ProjectCreateOneWithoutTestsInput {
  create: ProjectCreateWithoutTestsInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutTestsInput {
  id: ID
  name: String!
  users: UserCreateManyWithoutProjectsInput
  description: String
}

input ProjectCreateWithoutUsersInput {
  id: ID
  name: String!
  tests: TestCreateManyWithoutProjectInput
  description: String
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

enum ProjectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  description_ASC
  description_DESC
}

type ProjectPreviousValues {
  id: ID!
  createdAt: DateTime!
  name: String!
  updatedAt: DateTime!
  description: String
}

input ProjectScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateInput {
  name: String
  tests: TestUpdateManyWithoutProjectInput
  users: UserUpdateManyWithoutProjectsInput
  description: String
}

input ProjectUpdateManyDataInput {
  name: String
  description: String
}

input ProjectUpdateManyMutationInput {
  name: String
  description: String
}

input ProjectUpdateManyWithoutUsersInput {
  create: [ProjectCreateWithoutUsersInput!]
  delete: [ProjectWhereUniqueInput!]
  connect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  disconnect: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutUsersInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutUsersInput!]
  deleteMany: [ProjectScalarWhereInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput!
  data: ProjectUpdateManyDataInput!
}

input ProjectUpdateOneWithoutTestsInput {
  create: ProjectCreateWithoutTestsInput
  update: ProjectUpdateWithoutTestsDataInput
  upsert: ProjectUpsertWithoutTestsInput
  delete: Boolean
  disconnect: Boolean
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutTestsDataInput {
  name: String
  users: UserUpdateManyWithoutProjectsInput
  description: String
}

input ProjectUpdateWithoutUsersDataInput {
  name: String
  tests: TestUpdateManyWithoutProjectInput
  description: String
}

input ProjectUpdateWithWhereUniqueWithoutUsersInput {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateWithoutUsersDataInput!
}

input ProjectUpsertWithoutTestsInput {
  update: ProjectUpdateWithoutTestsDataInput!
  create: ProjectCreateWithoutTestsInput!
}

input ProjectUpsertWithWhereUniqueWithoutUsersInput {
  where: ProjectWhereUniqueInput!
  update: ProjectUpdateWithoutUsersDataInput!
  create: ProjectCreateWithoutUsersInput!
}

input ProjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  tests_every: TestWhereInput
  tests_some: TestWhereInput
  tests_none: TestWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  id: ID
}

type Query {
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  refreshTokenList(where: RefreshTokenListWhereUniqueInput!): RefreshTokenList
  refreshTokenLists(where: RefreshTokenListWhereInput, orderBy: RefreshTokenListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RefreshTokenList]!
  refreshTokenListsConnection(where: RefreshTokenListWhereInput, orderBy: RefreshTokenListOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RefreshTokenListConnection!
  test(where: TestWhereUniqueInput!): Test
  tests(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Test]!
  testsConnection(where: TestWhereInput, orderBy: TestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TestConnection!
  testSession(where: TestSessionWhereUniqueInput!): TestSession
  testSessions(where: TestSessionWhereInput, orderBy: TestSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TestSession]!
  testSessionsConnection(where: TestSessionWhereInput, orderBy: TestSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TestSessionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  variation(where: VariationWhereUniqueInput!): Variation
  variations(where: VariationWhereInput, orderBy: VariationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Variation]!
  variationsConnection(where: VariationWhereInput, orderBy: VariationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VariationConnection!
  node(id: ID!): Node
}

type RefreshTokenList {
  userId: ID!
  refreshToken: String!
}

type RefreshTokenListConnection {
  pageInfo: PageInfo!
  edges: [RefreshTokenListEdge]!
  aggregate: AggregateRefreshTokenList!
}

input RefreshTokenListCreateInput {
  userId: ID
  refreshToken: String!
}

type RefreshTokenListEdge {
  node: RefreshTokenList!
  cursor: String!
}

enum RefreshTokenListOrderByInput {
  userId_ASC
  userId_DESC
  refreshToken_ASC
  refreshToken_DESC
}

type RefreshTokenListPreviousValues {
  userId: ID!
  refreshToken: String!
}

type RefreshTokenListSubscriptionPayload {
  mutation: MutationType!
  node: RefreshTokenList
  updatedFields: [String!]
  previousValues: RefreshTokenListPreviousValues
}

input RefreshTokenListSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RefreshTokenListWhereInput
  AND: [RefreshTokenListSubscriptionWhereInput!]
  OR: [RefreshTokenListSubscriptionWhereInput!]
  NOT: [RefreshTokenListSubscriptionWhereInput!]
}

input RefreshTokenListUpdateInput {
  refreshToken: String
}

input RefreshTokenListUpdateManyMutationInput {
  refreshToken: String
}

input RefreshTokenListWhereInput {
  userId: ID
  userId_not: ID
  userId_in: [ID!]
  userId_not_in: [ID!]
  userId_lt: ID
  userId_lte: ID
  userId_gt: ID
  userId_gte: ID
  userId_contains: ID
  userId_not_contains: ID
  userId_starts_with: ID
  userId_not_starts_with: ID
  userId_ends_with: ID
  userId_not_ends_with: ID
  refreshToken: String
  refreshToken_not: String
  refreshToken_in: [String!]
  refreshToken_not_in: [String!]
  refreshToken_lt: String
  refreshToken_lte: String
  refreshToken_gt: String
  refreshToken_gte: String
  refreshToken_contains: String
  refreshToken_not_contains: String
  refreshToken_starts_with: String
  refreshToken_not_starts_with: String
  refreshToken_ends_with: String
  refreshToken_not_ends_with: String
  AND: [RefreshTokenListWhereInput!]
  OR: [RefreshTokenListWhereInput!]
  NOT: [RefreshTokenListWhereInput!]
}

input RefreshTokenListWhereUniqueInput {
  userId: ID
  refreshToken: String
}

enum Role {
  OWNER
  CUSTOMER
}

type Subscription {
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
  refreshTokenList(where: RefreshTokenListSubscriptionWhereInput): RefreshTokenListSubscriptionPayload
  test(where: TestSubscriptionWhereInput): TestSubscriptionPayload
  testSession(where: TestSessionSubscriptionWhereInput): TestSessionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  variation(where: VariationSubscriptionWhereInput): VariationSubscriptionPayload
}

type Test {
  id: ID!
  createdAt: DateTime!
  name: String!
  project: Project
  updatedAt: DateTime!
  variations(where: VariationWhereInput, orderBy: VariationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Variation!]
}

type TestConnection {
  pageInfo: PageInfo!
  edges: [TestEdge]!
  aggregate: AggregateTest!
}

input TestCreateInput {
  id: ID
  name: String!
  project: ProjectCreateOneWithoutTestsInput
  variations: VariationCreateManyWithoutTestInput
}

input TestCreateManyWithoutProjectInput {
  create: [TestCreateWithoutProjectInput!]
  connect: [TestWhereUniqueInput!]
}

input TestCreateOneWithoutVariationsInput {
  create: TestCreateWithoutVariationsInput
  connect: TestWhereUniqueInput
}

input TestCreateWithoutProjectInput {
  id: ID
  name: String!
  variations: VariationCreateManyWithoutTestInput
}

input TestCreateWithoutVariationsInput {
  id: ID
  name: String!
  project: ProjectCreateOneWithoutTestsInput
}

type TestEdge {
  node: Test!
  cursor: String!
}

enum TestOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TestPreviousValues {
  id: ID!
  createdAt: DateTime!
  name: String!
  updatedAt: DateTime!
}

input TestScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TestScalarWhereInput!]
  OR: [TestScalarWhereInput!]
  NOT: [TestScalarWhereInput!]
}

type TestSession {
  id: ID!
  createdAt: DateTime!
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float!
  isSameDimensions: Boolean
  updatedAt: DateTime!
  variation: Variation
  baselineForDiffRef: TestSession
  baselineRef: Variation
  diffBaseline: TestSession
  state: TestSessionState!
  stateChangedByUser: User
  stateComment: String
  autoBaseline: Boolean!
}

type TestSessionConnection {
  pageInfo: PageInfo!
  edges: [TestSessionEdge]!
  aggregate: AggregateTestSession!
}

input TestSessionCreateInput {
  id: ID
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float!
  isSameDimensions: Boolean
  variation: VariationCreateOneWithoutTestSessionsInput
  baselineForDiffRef: TestSessionCreateOneWithoutDiffBaselineInput
  baselineRef: VariationCreateOneWithoutBaselineVariationRefInput
  diffBaseline: TestSessionCreateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserCreateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionCreateManyWithoutVariationInput {
  create: [TestSessionCreateWithoutVariationInput!]
  connect: [TestSessionWhereUniqueInput!]
}

input TestSessionCreateOneWithoutBaselineForDiffRefInput {
  create: TestSessionCreateWithoutBaselineForDiffRefInput
  connect: TestSessionWhereUniqueInput
}

input TestSessionCreateOneWithoutBaselineRefInput {
  create: TestSessionCreateWithoutBaselineRefInput
  connect: TestSessionWhereUniqueInput
}

input TestSessionCreateOneWithoutDiffBaselineInput {
  create: TestSessionCreateWithoutDiffBaselineInput
  connect: TestSessionWhereUniqueInput
}

input TestSessionCreateWithoutBaselineForDiffRefInput {
  id: ID
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float!
  isSameDimensions: Boolean
  variation: VariationCreateOneWithoutTestSessionsInput
  baselineRef: VariationCreateOneWithoutBaselineVariationRefInput
  diffBaseline: TestSessionCreateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserCreateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionCreateWithoutBaselineRefInput {
  id: ID
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float!
  isSameDimensions: Boolean
  variation: VariationCreateOneWithoutTestSessionsInput
  baselineForDiffRef: TestSessionCreateOneWithoutDiffBaselineInput
  diffBaseline: TestSessionCreateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserCreateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionCreateWithoutDiffBaselineInput {
  id: ID
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float!
  isSameDimensions: Boolean
  variation: VariationCreateOneWithoutTestSessionsInput
  baselineForDiffRef: TestSessionCreateOneWithoutDiffBaselineInput
  baselineRef: VariationCreateOneWithoutBaselineVariationRefInput
  state: TestSessionState
  stateChangedByUser: UserCreateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionCreateWithoutVariationInput {
  id: ID
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float!
  isSameDimensions: Boolean
  baselineForDiffRef: TestSessionCreateOneWithoutDiffBaselineInput
  baselineRef: VariationCreateOneWithoutBaselineVariationRefInput
  diffBaseline: TestSessionCreateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserCreateOneInput
  stateComment: String
  autoBaseline: Boolean
}

type TestSessionEdge {
  node: TestSession!
  cursor: String!
}

enum TestSessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  diffImageKey_ASC
  diffImageKey_DESC
  imageKey_ASC
  imageKey_DESC
  misMatchPercentage_ASC
  misMatchPercentage_DESC
  misMatchTolerance_ASC
  misMatchTolerance_DESC
  isSameDimensions_ASC
  isSameDimensions_DESC
  updatedAt_ASC
  updatedAt_DESC
  state_ASC
  state_DESC
  stateComment_ASC
  stateComment_DESC
  autoBaseline_ASC
  autoBaseline_DESC
}

type TestSessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float!
  isSameDimensions: Boolean
  updatedAt: DateTime!
  state: TestSessionState!
  stateComment: String
  autoBaseline: Boolean!
}

input TestSessionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  diffImageKey: String
  diffImageKey_not: String
  diffImageKey_in: [String!]
  diffImageKey_not_in: [String!]
  diffImageKey_lt: String
  diffImageKey_lte: String
  diffImageKey_gt: String
  diffImageKey_gte: String
  diffImageKey_contains: String
  diffImageKey_not_contains: String
  diffImageKey_starts_with: String
  diffImageKey_not_starts_with: String
  diffImageKey_ends_with: String
  diffImageKey_not_ends_with: String
  imageKey: String
  imageKey_not: String
  imageKey_in: [String!]
  imageKey_not_in: [String!]
  imageKey_lt: String
  imageKey_lte: String
  imageKey_gt: String
  imageKey_gte: String
  imageKey_contains: String
  imageKey_not_contains: String
  imageKey_starts_with: String
  imageKey_not_starts_with: String
  imageKey_ends_with: String
  imageKey_not_ends_with: String
  misMatchPercentage: Float
  misMatchPercentage_not: Float
  misMatchPercentage_in: [Float!]
  misMatchPercentage_not_in: [Float!]
  misMatchPercentage_lt: Float
  misMatchPercentage_lte: Float
  misMatchPercentage_gt: Float
  misMatchPercentage_gte: Float
  misMatchTolerance: Float
  misMatchTolerance_not: Float
  misMatchTolerance_in: [Float!]
  misMatchTolerance_not_in: [Float!]
  misMatchTolerance_lt: Float
  misMatchTolerance_lte: Float
  misMatchTolerance_gt: Float
  misMatchTolerance_gte: Float
  isSameDimensions: Boolean
  isSameDimensions_not: Boolean
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  state: TestSessionState
  state_not: TestSessionState
  state_in: [TestSessionState!]
  state_not_in: [TestSessionState!]
  stateComment: String
  stateComment_not: String
  stateComment_in: [String!]
  stateComment_not_in: [String!]
  stateComment_lt: String
  stateComment_lte: String
  stateComment_gt: String
  stateComment_gte: String
  stateComment_contains: String
  stateComment_not_contains: String
  stateComment_starts_with: String
  stateComment_not_starts_with: String
  stateComment_ends_with: String
  stateComment_not_ends_with: String
  autoBaseline: Boolean
  autoBaseline_not: Boolean
  AND: [TestSessionScalarWhereInput!]
  OR: [TestSessionScalarWhereInput!]
  NOT: [TestSessionScalarWhereInput!]
}

enum TestSessionState {
  PENDING
  UNRESOLVED
  ACCEPTED
  DECLINED
}

type TestSessionSubscriptionPayload {
  mutation: MutationType!
  node: TestSession
  updatedFields: [String!]
  previousValues: TestSessionPreviousValues
}

input TestSessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TestSessionWhereInput
  AND: [TestSessionSubscriptionWhereInput!]
  OR: [TestSessionSubscriptionWhereInput!]
  NOT: [TestSessionSubscriptionWhereInput!]
}

input TestSessionUpdateInput {
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float
  isSameDimensions: Boolean
  variation: VariationUpdateOneWithoutTestSessionsInput
  baselineForDiffRef: TestSessionUpdateOneWithoutDiffBaselineInput
  baselineRef: VariationUpdateOneWithoutBaselineVariationRefInput
  diffBaseline: TestSessionUpdateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserUpdateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionUpdateManyDataInput {
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float
  isSameDimensions: Boolean
  state: TestSessionState
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionUpdateManyMutationInput {
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float
  isSameDimensions: Boolean
  state: TestSessionState
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionUpdateManyWithoutVariationInput {
  create: [TestSessionCreateWithoutVariationInput!]
  delete: [TestSessionWhereUniqueInput!]
  connect: [TestSessionWhereUniqueInput!]
  set: [TestSessionWhereUniqueInput!]
  disconnect: [TestSessionWhereUniqueInput!]
  update: [TestSessionUpdateWithWhereUniqueWithoutVariationInput!]
  upsert: [TestSessionUpsertWithWhereUniqueWithoutVariationInput!]
  deleteMany: [TestSessionScalarWhereInput!]
  updateMany: [TestSessionUpdateManyWithWhereNestedInput!]
}

input TestSessionUpdateManyWithWhereNestedInput {
  where: TestSessionScalarWhereInput!
  data: TestSessionUpdateManyDataInput!
}

input TestSessionUpdateOneWithoutBaselineForDiffRefInput {
  create: TestSessionCreateWithoutBaselineForDiffRefInput
  update: TestSessionUpdateWithoutBaselineForDiffRefDataInput
  upsert: TestSessionUpsertWithoutBaselineForDiffRefInput
  delete: Boolean
  disconnect: Boolean
  connect: TestSessionWhereUniqueInput
}

input TestSessionUpdateOneWithoutBaselineRefInput {
  create: TestSessionCreateWithoutBaselineRefInput
  update: TestSessionUpdateWithoutBaselineRefDataInput
  upsert: TestSessionUpsertWithoutBaselineRefInput
  delete: Boolean
  disconnect: Boolean
  connect: TestSessionWhereUniqueInput
}

input TestSessionUpdateOneWithoutDiffBaselineInput {
  create: TestSessionCreateWithoutDiffBaselineInput
  update: TestSessionUpdateWithoutDiffBaselineDataInput
  upsert: TestSessionUpsertWithoutDiffBaselineInput
  delete: Boolean
  disconnect: Boolean
  connect: TestSessionWhereUniqueInput
}

input TestSessionUpdateWithoutBaselineForDiffRefDataInput {
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float
  isSameDimensions: Boolean
  variation: VariationUpdateOneWithoutTestSessionsInput
  baselineRef: VariationUpdateOneWithoutBaselineVariationRefInput
  diffBaseline: TestSessionUpdateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserUpdateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionUpdateWithoutBaselineRefDataInput {
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float
  isSameDimensions: Boolean
  variation: VariationUpdateOneWithoutTestSessionsInput
  baselineForDiffRef: TestSessionUpdateOneWithoutDiffBaselineInput
  diffBaseline: TestSessionUpdateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserUpdateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionUpdateWithoutDiffBaselineDataInput {
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float
  isSameDimensions: Boolean
  variation: VariationUpdateOneWithoutTestSessionsInput
  baselineForDiffRef: TestSessionUpdateOneWithoutDiffBaselineInput
  baselineRef: VariationUpdateOneWithoutBaselineVariationRefInput
  state: TestSessionState
  stateChangedByUser: UserUpdateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionUpdateWithoutVariationDataInput {
  diffImageKey: String
  imageKey: String
  misMatchPercentage: Float
  misMatchTolerance: Float
  isSameDimensions: Boolean
  baselineForDiffRef: TestSessionUpdateOneWithoutDiffBaselineInput
  baselineRef: VariationUpdateOneWithoutBaselineVariationRefInput
  diffBaseline: TestSessionUpdateOneWithoutBaselineForDiffRefInput
  state: TestSessionState
  stateChangedByUser: UserUpdateOneInput
  stateComment: String
  autoBaseline: Boolean
}

input TestSessionUpdateWithWhereUniqueWithoutVariationInput {
  where: TestSessionWhereUniqueInput!
  data: TestSessionUpdateWithoutVariationDataInput!
}

input TestSessionUpsertWithoutBaselineForDiffRefInput {
  update: TestSessionUpdateWithoutBaselineForDiffRefDataInput!
  create: TestSessionCreateWithoutBaselineForDiffRefInput!
}

input TestSessionUpsertWithoutBaselineRefInput {
  update: TestSessionUpdateWithoutBaselineRefDataInput!
  create: TestSessionCreateWithoutBaselineRefInput!
}

input TestSessionUpsertWithoutDiffBaselineInput {
  update: TestSessionUpdateWithoutDiffBaselineDataInput!
  create: TestSessionCreateWithoutDiffBaselineInput!
}

input TestSessionUpsertWithWhereUniqueWithoutVariationInput {
  where: TestSessionWhereUniqueInput!
  update: TestSessionUpdateWithoutVariationDataInput!
  create: TestSessionCreateWithoutVariationInput!
}

input TestSessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  diffImageKey: String
  diffImageKey_not: String
  diffImageKey_in: [String!]
  diffImageKey_not_in: [String!]
  diffImageKey_lt: String
  diffImageKey_lte: String
  diffImageKey_gt: String
  diffImageKey_gte: String
  diffImageKey_contains: String
  diffImageKey_not_contains: String
  diffImageKey_starts_with: String
  diffImageKey_not_starts_with: String
  diffImageKey_ends_with: String
  diffImageKey_not_ends_with: String
  imageKey: String
  imageKey_not: String
  imageKey_in: [String!]
  imageKey_not_in: [String!]
  imageKey_lt: String
  imageKey_lte: String
  imageKey_gt: String
  imageKey_gte: String
  imageKey_contains: String
  imageKey_not_contains: String
  imageKey_starts_with: String
  imageKey_not_starts_with: String
  imageKey_ends_with: String
  imageKey_not_ends_with: String
  misMatchPercentage: Float
  misMatchPercentage_not: Float
  misMatchPercentage_in: [Float!]
  misMatchPercentage_not_in: [Float!]
  misMatchPercentage_lt: Float
  misMatchPercentage_lte: Float
  misMatchPercentage_gt: Float
  misMatchPercentage_gte: Float
  misMatchTolerance: Float
  misMatchTolerance_not: Float
  misMatchTolerance_in: [Float!]
  misMatchTolerance_not_in: [Float!]
  misMatchTolerance_lt: Float
  misMatchTolerance_lte: Float
  misMatchTolerance_gt: Float
  misMatchTolerance_gte: Float
  isSameDimensions: Boolean
  isSameDimensions_not: Boolean
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  variation: VariationWhereInput
  baselineForDiffRef: TestSessionWhereInput
  baselineRef: VariationWhereInput
  diffBaseline: TestSessionWhereInput
  state: TestSessionState
  state_not: TestSessionState
  state_in: [TestSessionState!]
  state_not_in: [TestSessionState!]
  stateChangedByUser: UserWhereInput
  stateComment: String
  stateComment_not: String
  stateComment_in: [String!]
  stateComment_not_in: [String!]
  stateComment_lt: String
  stateComment_lte: String
  stateComment_gt: String
  stateComment_gte: String
  stateComment_contains: String
  stateComment_not_contains: String
  stateComment_starts_with: String
  stateComment_not_starts_with: String
  stateComment_ends_with: String
  stateComment_not_ends_with: String
  autoBaseline: Boolean
  autoBaseline_not: Boolean
  AND: [TestSessionWhereInput!]
  OR: [TestSessionWhereInput!]
  NOT: [TestSessionWhereInput!]
}

input TestSessionWhereUniqueInput {
  id: ID
}

type TestSubscriptionPayload {
  mutation: MutationType!
  node: Test
  updatedFields: [String!]
  previousValues: TestPreviousValues
}

input TestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TestWhereInput
  AND: [TestSubscriptionWhereInput!]
  OR: [TestSubscriptionWhereInput!]
  NOT: [TestSubscriptionWhereInput!]
}

input TestUpdateInput {
  name: String
  project: ProjectUpdateOneWithoutTestsInput
  variations: VariationUpdateManyWithoutTestInput
}

input TestUpdateManyDataInput {
  name: String
}

input TestUpdateManyMutationInput {
  name: String
}

input TestUpdateManyWithoutProjectInput {
  create: [TestCreateWithoutProjectInput!]
  delete: [TestWhereUniqueInput!]
  connect: [TestWhereUniqueInput!]
  set: [TestWhereUniqueInput!]
  disconnect: [TestWhereUniqueInput!]
  update: [TestUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [TestUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [TestScalarWhereInput!]
  updateMany: [TestUpdateManyWithWhereNestedInput!]
}

input TestUpdateManyWithWhereNestedInput {
  where: TestScalarWhereInput!
  data: TestUpdateManyDataInput!
}

input TestUpdateOneWithoutVariationsInput {
  create: TestCreateWithoutVariationsInput
  update: TestUpdateWithoutVariationsDataInput
  upsert: TestUpsertWithoutVariationsInput
  delete: Boolean
  disconnect: Boolean
  connect: TestWhereUniqueInput
}

input TestUpdateWithoutProjectDataInput {
  name: String
  variations: VariationUpdateManyWithoutTestInput
}

input TestUpdateWithoutVariationsDataInput {
  name: String
  project: ProjectUpdateOneWithoutTestsInput
}

input TestUpdateWithWhereUniqueWithoutProjectInput {
  where: TestWhereUniqueInput!
  data: TestUpdateWithoutProjectDataInput!
}

input TestUpsertWithoutVariationsInput {
  update: TestUpdateWithoutVariationsDataInput!
  create: TestCreateWithoutVariationsInput!
}

input TestUpsertWithWhereUniqueWithoutProjectInput {
  where: TestWhereUniqueInput!
  update: TestUpdateWithoutProjectDataInput!
  create: TestCreateWithoutProjectInput!
}

input TestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  project: ProjectWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  variations_every: VariationWhereInput
  variations_some: VariationWhereInput
  variations_none: VariationWhereInput
  AND: [TestWhereInput!]
  OR: [TestWhereInput!]
  NOT: [TestWhereInput!]
}

input TestWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean!
  role: Role!
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project!]
  apiKey: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean
  role: Role
  projects: ProjectCreateManyWithoutUsersInput
  apiKey: String!
}

input UserCreateManyWithoutProjectsInput {
  create: [UserCreateWithoutProjectsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutProjectsInput {
  id: ID
  email: String!
  password: String!
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean
  role: Role
  apiKey: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  lastname_ASC
  lastname_DESC
  phoneNumber_ASC
  phoneNumber_DESC
  forename_ASC
  forename_DESC
  active_ASC
  active_DESC
  role_ASC
  role_DESC
  apiKey_ASC
  apiKey_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean!
  role: Role!
  apiKey: String!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  forename: String
  forename_not: String
  forename_in: [String!]
  forename_not_in: [String!]
  forename_lt: String
  forename_lte: String
  forename_gt: String
  forename_gte: String
  forename_contains: String
  forename_not_contains: String
  forename_starts_with: String
  forename_not_starts_with: String
  forename_ends_with: String
  forename_not_ends_with: String
  active: Boolean
  active_not: Boolean
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  apiKey: String
  apiKey_not: String
  apiKey_in: [String!]
  apiKey_not_in: [String!]
  apiKey_lt: String
  apiKey_lte: String
  apiKey_gt: String
  apiKey_gte: String
  apiKey_contains: String
  apiKey_not_contains: String
  apiKey_starts_with: String
  apiKey_not_starts_with: String
  apiKey_ends_with: String
  apiKey_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  password: String
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean
  role: Role
  projects: ProjectUpdateManyWithoutUsersInput
  apiKey: String
}

input UserUpdateInput {
  email: String
  password: String
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean
  role: Role
  projects: ProjectUpdateManyWithoutUsersInput
  apiKey: String
}

input UserUpdateManyDataInput {
  email: String
  password: String
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean
  role: Role
  apiKey: String
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean
  role: Role
  apiKey: String
}

input UserUpdateManyWithoutProjectsInput {
  create: [UserCreateWithoutProjectsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutProjectsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutProjectsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutProjectsDataInput {
  email: String
  password: String
  lastname: String
  phoneNumber: String
  forename: String
  active: Boolean
  role: Role
  apiKey: String
}

input UserUpdateWithWhereUniqueWithoutProjectsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutProjectsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutProjectsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutProjectsDataInput!
  create: UserCreateWithoutProjectsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  lastname: String
  lastname_not: String
  lastname_in: [String!]
  lastname_not_in: [String!]
  lastname_lt: String
  lastname_lte: String
  lastname_gt: String
  lastname_gte: String
  lastname_contains: String
  lastname_not_contains: String
  lastname_starts_with: String
  lastname_not_starts_with: String
  lastname_ends_with: String
  lastname_not_ends_with: String
  phoneNumber: String
  phoneNumber_not: String
  phoneNumber_in: [String!]
  phoneNumber_not_in: [String!]
  phoneNumber_lt: String
  phoneNumber_lte: String
  phoneNumber_gt: String
  phoneNumber_gte: String
  phoneNumber_contains: String
  phoneNumber_not_contains: String
  phoneNumber_starts_with: String
  phoneNumber_not_starts_with: String
  phoneNumber_ends_with: String
  phoneNumber_not_ends_with: String
  forename: String
  forename_not: String
  forename_in: [String!]
  forename_not_in: [String!]
  forename_lt: String
  forename_lte: String
  forename_gt: String
  forename_gte: String
  forename_contains: String
  forename_not_contains: String
  forename_starts_with: String
  forename_not_starts_with: String
  forename_ends_with: String
  forename_not_ends_with: String
  active: Boolean
  active_not: Boolean
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  projects_every: ProjectWhereInput
  projects_some: ProjectWhereInput
  projects_none: ProjectWhereInput
  apiKey: String
  apiKey_not: String
  apiKey_in: [String!]
  apiKey_not_in: [String!]
  apiKey_lt: String
  apiKey_lte: String
  apiKey_gt: String
  apiKey_gte: String
  apiKey_contains: String
  apiKey_not_contains: String
  apiKey_starts_with: String
  apiKey_not_starts_with: String
  apiKey_ends_with: String
  apiKey_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}

type Variation {
  id: ID!
  additionalData: Json
  browserName: String
  createdAt: DateTime!
  deviceName: String
  test: Test
  testSessions(where: TestSessionWhereInput, orderBy: TestSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [TestSession!]
  updatedAt: DateTime!
  baselineVariationRef: TestSession
}

type VariationConnection {
  pageInfo: PageInfo!
  edges: [VariationEdge]!
  aggregate: AggregateVariation!
}

input VariationCreateInput {
  id: ID
  additionalData: Json
  browserName: String
  deviceName: String
  test: TestCreateOneWithoutVariationsInput
  testSessions: TestSessionCreateManyWithoutVariationInput
  baselineVariationRef: TestSessionCreateOneWithoutBaselineRefInput
}

input VariationCreateManyWithoutTestInput {
  create: [VariationCreateWithoutTestInput!]
  connect: [VariationWhereUniqueInput!]
}

input VariationCreateOneWithoutBaselineVariationRefInput {
  create: VariationCreateWithoutBaselineVariationRefInput
  connect: VariationWhereUniqueInput
}

input VariationCreateOneWithoutTestSessionsInput {
  create: VariationCreateWithoutTestSessionsInput
  connect: VariationWhereUniqueInput
}

input VariationCreateWithoutBaselineVariationRefInput {
  id: ID
  additionalData: Json
  browserName: String
  deviceName: String
  test: TestCreateOneWithoutVariationsInput
  testSessions: TestSessionCreateManyWithoutVariationInput
}

input VariationCreateWithoutTestInput {
  id: ID
  additionalData: Json
  browserName: String
  deviceName: String
  testSessions: TestSessionCreateManyWithoutVariationInput
  baselineVariationRef: TestSessionCreateOneWithoutBaselineRefInput
}

input VariationCreateWithoutTestSessionsInput {
  id: ID
  additionalData: Json
  browserName: String
  deviceName: String
  test: TestCreateOneWithoutVariationsInput
  baselineVariationRef: TestSessionCreateOneWithoutBaselineRefInput
}

type VariationEdge {
  node: Variation!
  cursor: String!
}

enum VariationOrderByInput {
  id_ASC
  id_DESC
  additionalData_ASC
  additionalData_DESC
  browserName_ASC
  browserName_DESC
  createdAt_ASC
  createdAt_DESC
  deviceName_ASC
  deviceName_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type VariationPreviousValues {
  id: ID!
  additionalData: Json
  browserName: String
  createdAt: DateTime!
  deviceName: String
  updatedAt: DateTime!
}

input VariationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  browserName: String
  browserName_not: String
  browserName_in: [String!]
  browserName_not_in: [String!]
  browserName_lt: String
  browserName_lte: String
  browserName_gt: String
  browserName_gte: String
  browserName_contains: String
  browserName_not_contains: String
  browserName_starts_with: String
  browserName_not_starts_with: String
  browserName_ends_with: String
  browserName_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deviceName: String
  deviceName_not: String
  deviceName_in: [String!]
  deviceName_not_in: [String!]
  deviceName_lt: String
  deviceName_lte: String
  deviceName_gt: String
  deviceName_gte: String
  deviceName_contains: String
  deviceName_not_contains: String
  deviceName_starts_with: String
  deviceName_not_starts_with: String
  deviceName_ends_with: String
  deviceName_not_ends_with: String
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [VariationScalarWhereInput!]
  OR: [VariationScalarWhereInput!]
  NOT: [VariationScalarWhereInput!]
}

type VariationSubscriptionPayload {
  mutation: MutationType!
  node: Variation
  updatedFields: [String!]
  previousValues: VariationPreviousValues
}

input VariationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VariationWhereInput
  AND: [VariationSubscriptionWhereInput!]
  OR: [VariationSubscriptionWhereInput!]
  NOT: [VariationSubscriptionWhereInput!]
}

input VariationUpdateInput {
  additionalData: Json
  browserName: String
  deviceName: String
  test: TestUpdateOneWithoutVariationsInput
  testSessions: TestSessionUpdateManyWithoutVariationInput
  baselineVariationRef: TestSessionUpdateOneWithoutBaselineRefInput
}

input VariationUpdateManyDataInput {
  additionalData: Json
  browserName: String
  deviceName: String
}

input VariationUpdateManyMutationInput {
  additionalData: Json
  browserName: String
  deviceName: String
}

input VariationUpdateManyWithoutTestInput {
  create: [VariationCreateWithoutTestInput!]
  delete: [VariationWhereUniqueInput!]
  connect: [VariationWhereUniqueInput!]
  set: [VariationWhereUniqueInput!]
  disconnect: [VariationWhereUniqueInput!]
  update: [VariationUpdateWithWhereUniqueWithoutTestInput!]
  upsert: [VariationUpsertWithWhereUniqueWithoutTestInput!]
  deleteMany: [VariationScalarWhereInput!]
  updateMany: [VariationUpdateManyWithWhereNestedInput!]
}

input VariationUpdateManyWithWhereNestedInput {
  where: VariationScalarWhereInput!
  data: VariationUpdateManyDataInput!
}

input VariationUpdateOneWithoutBaselineVariationRefInput {
  create: VariationCreateWithoutBaselineVariationRefInput
  update: VariationUpdateWithoutBaselineVariationRefDataInput
  upsert: VariationUpsertWithoutBaselineVariationRefInput
  delete: Boolean
  disconnect: Boolean
  connect: VariationWhereUniqueInput
}

input VariationUpdateOneWithoutTestSessionsInput {
  create: VariationCreateWithoutTestSessionsInput
  update: VariationUpdateWithoutTestSessionsDataInput
  upsert: VariationUpsertWithoutTestSessionsInput
  delete: Boolean
  disconnect: Boolean
  connect: VariationWhereUniqueInput
}

input VariationUpdateWithoutBaselineVariationRefDataInput {
  additionalData: Json
  browserName: String
  deviceName: String
  test: TestUpdateOneWithoutVariationsInput
  testSessions: TestSessionUpdateManyWithoutVariationInput
}

input VariationUpdateWithoutTestDataInput {
  additionalData: Json
  browserName: String
  deviceName: String
  testSessions: TestSessionUpdateManyWithoutVariationInput
  baselineVariationRef: TestSessionUpdateOneWithoutBaselineRefInput
}

input VariationUpdateWithoutTestSessionsDataInput {
  additionalData: Json
  browserName: String
  deviceName: String
  test: TestUpdateOneWithoutVariationsInput
  baselineVariationRef: TestSessionUpdateOneWithoutBaselineRefInput
}

input VariationUpdateWithWhereUniqueWithoutTestInput {
  where: VariationWhereUniqueInput!
  data: VariationUpdateWithoutTestDataInput!
}

input VariationUpsertWithoutBaselineVariationRefInput {
  update: VariationUpdateWithoutBaselineVariationRefDataInput!
  create: VariationCreateWithoutBaselineVariationRefInput!
}

input VariationUpsertWithoutTestSessionsInput {
  update: VariationUpdateWithoutTestSessionsDataInput!
  create: VariationCreateWithoutTestSessionsInput!
}

input VariationUpsertWithWhereUniqueWithoutTestInput {
  where: VariationWhereUniqueInput!
  update: VariationUpdateWithoutTestDataInput!
  create: VariationCreateWithoutTestInput!
}

input VariationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  browserName: String
  browserName_not: String
  browserName_in: [String!]
  browserName_not_in: [String!]
  browserName_lt: String
  browserName_lte: String
  browserName_gt: String
  browserName_gte: String
  browserName_contains: String
  browserName_not_contains: String
  browserName_starts_with: String
  browserName_not_starts_with: String
  browserName_ends_with: String
  browserName_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  deviceName: String
  deviceName_not: String
  deviceName_in: [String!]
  deviceName_not_in: [String!]
  deviceName_lt: String
  deviceName_lte: String
  deviceName_gt: String
  deviceName_gte: String
  deviceName_contains: String
  deviceName_not_contains: String
  deviceName_starts_with: String
  deviceName_not_starts_with: String
  deviceName_ends_with: String
  deviceName_not_ends_with: String
  test: TestWhereInput
  testSessions_every: TestSessionWhereInput
  testSessions_some: TestSessionWhereInput
  testSessions_none: TestSessionWhereInput
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  baselineVariationRef: TestSessionWhereInput
  AND: [VariationWhereInput!]
  OR: [VariationWhereInput!]
  NOT: [VariationWhereInput!]
}

input VariationWhereUniqueInput {
  id: ID
}
`