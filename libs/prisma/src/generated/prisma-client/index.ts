// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  project: (where?: ProjectWhereInput) => Promise<boolean>;
  refreshTokenList: (where?: RefreshTokenListWhereInput) => Promise<boolean>;
  test: (where?: TestWhereInput) => Promise<boolean>;
  testSession: (where?: TestSessionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  variation: (where?: VariationWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  project: (where: ProjectWhereUniqueInput) => ProjectNullablePromise;
  projects: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Project>;
  projectsConnection: (args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProjectConnectionPromise;
  refreshTokenList: (
    where: RefreshTokenListWhereUniqueInput
  ) => RefreshTokenListNullablePromise;
  refreshTokenLists: (args?: {
    where?: RefreshTokenListWhereInput;
    orderBy?: RefreshTokenListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<RefreshTokenList>;
  refreshTokenListsConnection: (args?: {
    where?: RefreshTokenListWhereInput;
    orderBy?: RefreshTokenListOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RefreshTokenListConnectionPromise;
  test: (where: TestWhereUniqueInput) => TestNullablePromise;
  tests: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Test>;
  testsConnection: (args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestConnectionPromise;
  testSession: (
    where: TestSessionWhereUniqueInput
  ) => TestSessionNullablePromise;
  testSessions: (args?: {
    where?: TestSessionWhereInput;
    orderBy?: TestSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TestSession>;
  testSessionsConnection: (args?: {
    where?: TestSessionWhereInput;
    orderBy?: TestSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TestSessionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  variation: (where: VariationWhereUniqueInput) => VariationNullablePromise;
  variations: (args?: {
    where?: VariationWhereInput;
    orderBy?: VariationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Variation>;
  variationsConnection: (args?: {
    where?: VariationWhereInput;
    orderBy?: VariationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VariationConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createProject: (data: ProjectCreateInput) => ProjectPromise;
  updateProject: (args: {
    data: ProjectUpdateInput;
    where: ProjectWhereUniqueInput;
  }) => ProjectPromise;
  updateManyProjects: (args: {
    data: ProjectUpdateManyMutationInput;
    where?: ProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertProject: (args: {
    where: ProjectWhereUniqueInput;
    create: ProjectCreateInput;
    update: ProjectUpdateInput;
  }) => ProjectPromise;
  deleteProject: (where: ProjectWhereUniqueInput) => ProjectPromise;
  deleteManyProjects: (where?: ProjectWhereInput) => BatchPayloadPromise;
  createRefreshTokenList: (
    data: RefreshTokenListCreateInput
  ) => RefreshTokenListPromise;
  updateRefreshTokenList: (args: {
    data: RefreshTokenListUpdateInput;
    where: RefreshTokenListWhereUniqueInput;
  }) => RefreshTokenListPromise;
  updateManyRefreshTokenLists: (args: {
    data: RefreshTokenListUpdateManyMutationInput;
    where?: RefreshTokenListWhereInput;
  }) => BatchPayloadPromise;
  upsertRefreshTokenList: (args: {
    where: RefreshTokenListWhereUniqueInput;
    create: RefreshTokenListCreateInput;
    update: RefreshTokenListUpdateInput;
  }) => RefreshTokenListPromise;
  deleteRefreshTokenList: (
    where: RefreshTokenListWhereUniqueInput
  ) => RefreshTokenListPromise;
  deleteManyRefreshTokenLists: (
    where?: RefreshTokenListWhereInput
  ) => BatchPayloadPromise;
  createTest: (data: TestCreateInput) => TestPromise;
  updateTest: (args: {
    data: TestUpdateInput;
    where: TestWhereUniqueInput;
  }) => TestPromise;
  updateManyTests: (args: {
    data: TestUpdateManyMutationInput;
    where?: TestWhereInput;
  }) => BatchPayloadPromise;
  upsertTest: (args: {
    where: TestWhereUniqueInput;
    create: TestCreateInput;
    update: TestUpdateInput;
  }) => TestPromise;
  deleteTest: (where: TestWhereUniqueInput) => TestPromise;
  deleteManyTests: (where?: TestWhereInput) => BatchPayloadPromise;
  createTestSession: (data: TestSessionCreateInput) => TestSessionPromise;
  updateTestSession: (args: {
    data: TestSessionUpdateInput;
    where: TestSessionWhereUniqueInput;
  }) => TestSessionPromise;
  updateManyTestSessions: (args: {
    data: TestSessionUpdateManyMutationInput;
    where?: TestSessionWhereInput;
  }) => BatchPayloadPromise;
  upsertTestSession: (args: {
    where: TestSessionWhereUniqueInput;
    create: TestSessionCreateInput;
    update: TestSessionUpdateInput;
  }) => TestSessionPromise;
  deleteTestSession: (where: TestSessionWhereUniqueInput) => TestSessionPromise;
  deleteManyTestSessions: (
    where?: TestSessionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVariation: (data: VariationCreateInput) => VariationPromise;
  updateVariation: (args: {
    data: VariationUpdateInput;
    where: VariationWhereUniqueInput;
  }) => VariationPromise;
  updateManyVariations: (args: {
    data: VariationUpdateManyMutationInput;
    where?: VariationWhereInput;
  }) => BatchPayloadPromise;
  upsertVariation: (args: {
    where: VariationWhereUniqueInput;
    create: VariationCreateInput;
    update: VariationUpdateInput;
  }) => VariationPromise;
  deleteVariation: (where: VariationWhereUniqueInput) => VariationPromise;
  deleteManyVariations: (where?: VariationWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  project: (
    where?: ProjectSubscriptionWhereInput
  ) => ProjectSubscriptionPayloadSubscription;
  refreshTokenList: (
    where?: RefreshTokenListSubscriptionWhereInput
  ) => RefreshTokenListSubscriptionPayloadSubscription;
  test: (
    where?: TestSubscriptionWhereInput
  ) => TestSubscriptionPayloadSubscription;
  testSession: (
    where?: TestSessionSubscriptionWhereInput
  ) => TestSessionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  variation: (
    where?: VariationSubscriptionWhereInput
  ) => VariationSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TestSessionState =
  | "PENDING"
  | "UNRESOLVED"
  | "ACCEPTED"
  | "DECLINED";

export type Role = "OWNER" | "CUSTOMER";

export type TestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type VariationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "additionalData_ASC"
  | "additionalData_DESC"
  | "browserName_ASC"
  | "browserName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "deviceName_ASC"
  | "deviceName_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TestSessionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "diffImageKey_ASC"
  | "diffImageKey_DESC"
  | "imageKey_ASC"
  | "imageKey_DESC"
  | "misMatchPercentage_ASC"
  | "misMatchPercentage_DESC"
  | "misMatchTolerance_ASC"
  | "misMatchTolerance_DESC"
  | "isSameDimensions_ASC"
  | "isSameDimensions_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "state_ASC"
  | "state_DESC"
  | "stateComment_ASC"
  | "stateComment_DESC"
  | "autoBaseline_ASC"
  | "autoBaseline_DESC";

export type ProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "name_ASC"
  | "name_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "lastname_ASC"
  | "lastname_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "forename_ASC"
  | "forename_DESC"
  | "active_ASC"
  | "active_DESC"
  | "role_ASC"
  | "role_DESC"
  | "apiKey_ASC"
  | "apiKey_DESC";

export type RefreshTokenListOrderByInput =
  | "userId_ASC"
  | "userId_DESC"
  | "refreshToken_ASC"
  | "refreshToken_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface TestSessionUpdateWithWhereUniqueWithoutVariationInput {
  where: TestSessionWhereUniqueInput;
  data: TestSessionUpdateWithoutVariationDataInput;
}

export type ProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface VariationUpdateWithoutTestSessionsDataInput {
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  test?: Maybe<TestUpdateOneWithoutVariationsInput>;
  baselineVariationRef?: Maybe<TestSessionUpdateOneWithoutBaselineRefInput>;
}

export interface TestSessionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  diffImageKey?: Maybe<String>;
  diffImageKey_not?: Maybe<String>;
  diffImageKey_in?: Maybe<String[] | String>;
  diffImageKey_not_in?: Maybe<String[] | String>;
  diffImageKey_lt?: Maybe<String>;
  diffImageKey_lte?: Maybe<String>;
  diffImageKey_gt?: Maybe<String>;
  diffImageKey_gte?: Maybe<String>;
  diffImageKey_contains?: Maybe<String>;
  diffImageKey_not_contains?: Maybe<String>;
  diffImageKey_starts_with?: Maybe<String>;
  diffImageKey_not_starts_with?: Maybe<String>;
  diffImageKey_ends_with?: Maybe<String>;
  diffImageKey_not_ends_with?: Maybe<String>;
  imageKey?: Maybe<String>;
  imageKey_not?: Maybe<String>;
  imageKey_in?: Maybe<String[] | String>;
  imageKey_not_in?: Maybe<String[] | String>;
  imageKey_lt?: Maybe<String>;
  imageKey_lte?: Maybe<String>;
  imageKey_gt?: Maybe<String>;
  imageKey_gte?: Maybe<String>;
  imageKey_contains?: Maybe<String>;
  imageKey_not_contains?: Maybe<String>;
  imageKey_starts_with?: Maybe<String>;
  imageKey_not_starts_with?: Maybe<String>;
  imageKey_ends_with?: Maybe<String>;
  imageKey_not_ends_with?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchPercentage_not?: Maybe<Float>;
  misMatchPercentage_in?: Maybe<Float[] | Float>;
  misMatchPercentage_not_in?: Maybe<Float[] | Float>;
  misMatchPercentage_lt?: Maybe<Float>;
  misMatchPercentage_lte?: Maybe<Float>;
  misMatchPercentage_gt?: Maybe<Float>;
  misMatchPercentage_gte?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  misMatchTolerance_not?: Maybe<Float>;
  misMatchTolerance_in?: Maybe<Float[] | Float>;
  misMatchTolerance_not_in?: Maybe<Float[] | Float>;
  misMatchTolerance_lt?: Maybe<Float>;
  misMatchTolerance_lte?: Maybe<Float>;
  misMatchTolerance_gt?: Maybe<Float>;
  misMatchTolerance_gte?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  isSameDimensions_not?: Maybe<Boolean>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  variation?: Maybe<VariationWhereInput>;
  baselineForDiffRef?: Maybe<TestSessionWhereInput>;
  baselineRef?: Maybe<VariationWhereInput>;
  diffBaseline?: Maybe<TestSessionWhereInput>;
  state?: Maybe<TestSessionState>;
  state_not?: Maybe<TestSessionState>;
  state_in?: Maybe<TestSessionState[] | TestSessionState>;
  state_not_in?: Maybe<TestSessionState[] | TestSessionState>;
  stateChangedByUser?: Maybe<UserWhereInput>;
  stateComment?: Maybe<String>;
  stateComment_not?: Maybe<String>;
  stateComment_in?: Maybe<String[] | String>;
  stateComment_not_in?: Maybe<String[] | String>;
  stateComment_lt?: Maybe<String>;
  stateComment_lte?: Maybe<String>;
  stateComment_gt?: Maybe<String>;
  stateComment_gte?: Maybe<String>;
  stateComment_contains?: Maybe<String>;
  stateComment_not_contains?: Maybe<String>;
  stateComment_starts_with?: Maybe<String>;
  stateComment_not_starts_with?: Maybe<String>;
  stateComment_ends_with?: Maybe<String>;
  stateComment_not_ends_with?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
  autoBaseline_not?: Maybe<Boolean>;
  AND?: Maybe<TestSessionWhereInput[] | TestSessionWhereInput>;
  OR?: Maybe<TestSessionWhereInput[] | TestSessionWhereInput>;
  NOT?: Maybe<TestSessionWhereInput[] | TestSessionWhereInput>;
}

export interface TestUpdateOneWithoutVariationsInput {
  create?: Maybe<TestCreateWithoutVariationsInput>;
  update?: Maybe<TestUpdateWithoutVariationsDataInput>;
  upsert?: Maybe<TestUpsertWithoutVariationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TestWhereUniqueInput>;
}

export interface VariationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  browserName?: Maybe<String>;
  browserName_not?: Maybe<String>;
  browserName_in?: Maybe<String[] | String>;
  browserName_not_in?: Maybe<String[] | String>;
  browserName_lt?: Maybe<String>;
  browserName_lte?: Maybe<String>;
  browserName_gt?: Maybe<String>;
  browserName_gte?: Maybe<String>;
  browserName_contains?: Maybe<String>;
  browserName_not_contains?: Maybe<String>;
  browserName_starts_with?: Maybe<String>;
  browserName_not_starts_with?: Maybe<String>;
  browserName_ends_with?: Maybe<String>;
  browserName_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deviceName?: Maybe<String>;
  deviceName_not?: Maybe<String>;
  deviceName_in?: Maybe<String[] | String>;
  deviceName_not_in?: Maybe<String[] | String>;
  deviceName_lt?: Maybe<String>;
  deviceName_lte?: Maybe<String>;
  deviceName_gt?: Maybe<String>;
  deviceName_gte?: Maybe<String>;
  deviceName_contains?: Maybe<String>;
  deviceName_not_contains?: Maybe<String>;
  deviceName_starts_with?: Maybe<String>;
  deviceName_not_starts_with?: Maybe<String>;
  deviceName_ends_with?: Maybe<String>;
  deviceName_not_ends_with?: Maybe<String>;
  test?: Maybe<TestWhereInput>;
  testSessions_every?: Maybe<TestSessionWhereInput>;
  testSessions_some?: Maybe<TestSessionWhereInput>;
  testSessions_none?: Maybe<TestSessionWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  baselineVariationRef?: Maybe<TestSessionWhereInput>;
  AND?: Maybe<VariationWhereInput[] | VariationWhereInput>;
  OR?: Maybe<VariationWhereInput[] | VariationWhereInput>;
  NOT?: Maybe<VariationWhereInput[] | VariationWhereInput>;
}

export interface TestSessionCreateWithoutBaselineForDiffRefInput {
  id?: Maybe<ID_Input>;
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance: Float;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationCreateOneWithoutTestSessionsInput>;
  baselineRef?: Maybe<VariationCreateOneWithoutBaselineVariationRefInput>;
  diffBaseline?: Maybe<TestSessionCreateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserCreateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface TestSessionUpdateManyWithWhereNestedInput {
  where: TestSessionScalarWhereInput;
  data: TestSessionUpdateManyDataInput;
}

export interface VariationCreateOneWithoutBaselineVariationRefInput {
  create?: Maybe<VariationCreateWithoutBaselineVariationRefInput>;
  connect?: Maybe<VariationWhereUniqueInput>;
}

export interface TestUpdateWithoutVariationsDataInput {
  name?: Maybe<String>;
  project?: Maybe<ProjectUpdateOneWithoutTestsInput>;
}

export interface VariationCreateWithoutBaselineVariationRefInput {
  id?: Maybe<ID_Input>;
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  test?: Maybe<TestCreateOneWithoutVariationsInput>;
  testSessions?: Maybe<TestSessionCreateManyWithoutVariationInput>;
}

export interface VariationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VariationWhereInput>;
  AND?: Maybe<
    VariationSubscriptionWhereInput[] | VariationSubscriptionWhereInput
  >;
  OR?: Maybe<
    VariationSubscriptionWhereInput[] | VariationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VariationSubscriptionWhereInput[] | VariationSubscriptionWhereInput
  >;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  tests_every?: Maybe<TestWhereInput>;
  tests_some?: Maybe<TestWhereInput>;
  tests_none?: Maybe<TestWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  OR?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
  NOT?: Maybe<ProjectWhereInput[] | ProjectWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  lastname?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  forename?: Maybe<String>;
  active?: Maybe<Boolean>;
  role?: Maybe<Role>;
  projects?: Maybe<ProjectCreateManyWithoutUsersInput>;
  apiKey: String;
}

export interface TestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TestWhereInput>;
  AND?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
  OR?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
  NOT?: Maybe<TestSubscriptionWhereInput[] | TestSubscriptionWhereInput>;
}

export interface ProjectCreateManyWithoutUsersInput {
  create?: Maybe<
    ProjectCreateWithoutUsersInput[] | ProjectCreateWithoutUsersInput
  >;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
}

export interface RefreshTokenListSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RefreshTokenListWhereInput>;
  AND?: Maybe<
    | RefreshTokenListSubscriptionWhereInput[]
    | RefreshTokenListSubscriptionWhereInput
  >;
  OR?: Maybe<
    | RefreshTokenListSubscriptionWhereInput[]
    | RefreshTokenListSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | RefreshTokenListSubscriptionWhereInput[]
    | RefreshTokenListSubscriptionWhereInput
  >;
}

export interface ProjectCreateWithoutUsersInput {
  id?: Maybe<ID_Input>;
  name: String;
  tests?: Maybe<TestCreateManyWithoutProjectInput>;
  description?: Maybe<String>;
}

export interface VariationUpdateManyMutationInput {
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
}

export interface ProjectUpdateInput {
  name?: Maybe<String>;
  tests?: Maybe<TestUpdateManyWithoutProjectInput>;
  users?: Maybe<UserUpdateManyWithoutProjectsInput>;
  description?: Maybe<String>;
}

export interface VariationCreateInput {
  id?: Maybe<ID_Input>;
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  test?: Maybe<TestCreateOneWithoutVariationsInput>;
  testSessions?: Maybe<TestSessionCreateManyWithoutVariationInput>;
  baselineVariationRef?: Maybe<TestSessionCreateOneWithoutBaselineRefInput>;
}

export interface TestUpdateManyWithoutProjectInput {
  create?: Maybe<
    TestCreateWithoutProjectInput[] | TestCreateWithoutProjectInput
  >;
  delete?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>;
  connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>;
  set?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>;
  disconnect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>;
  update?: Maybe<
    | TestUpdateWithWhereUniqueWithoutProjectInput[]
    | TestUpdateWithWhereUniqueWithoutProjectInput
  >;
  upsert?: Maybe<
    | TestUpsertWithWhereUniqueWithoutProjectInput[]
    | TestUpsertWithWhereUniqueWithoutProjectInput
  >;
  deleteMany?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>;
  updateMany?: Maybe<
    TestUpdateManyWithWhereNestedInput[] | TestUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  lastname?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  forename?: Maybe<String>;
  active?: Maybe<Boolean>;
  role?: Maybe<Role>;
  apiKey?: Maybe<String>;
}

export interface TestUpdateWithWhereUniqueWithoutProjectInput {
  where: TestWhereUniqueInput;
  data: TestUpdateWithoutProjectDataInput;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  lastname?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  forename?: Maybe<String>;
  active?: Maybe<Boolean>;
  role?: Maybe<Role>;
  projects?: Maybe<ProjectUpdateManyWithoutUsersInput>;
  apiKey?: Maybe<String>;
}

export interface TestUpdateWithoutProjectDataInput {
  name?: Maybe<String>;
  variations?: Maybe<VariationUpdateManyWithoutTestInput>;
}

export interface TestSessionUpdateInput {
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationUpdateOneWithoutTestSessionsInput>;
  baselineForDiffRef?: Maybe<TestSessionUpdateOneWithoutDiffBaselineInput>;
  baselineRef?: Maybe<VariationUpdateOneWithoutBaselineVariationRefInput>;
  diffBaseline?: Maybe<TestSessionUpdateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserUpdateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface VariationUpdateManyWithoutTestInput {
  create?: Maybe<
    VariationCreateWithoutTestInput[] | VariationCreateWithoutTestInput
  >;
  delete?: Maybe<VariationWhereUniqueInput[] | VariationWhereUniqueInput>;
  connect?: Maybe<VariationWhereUniqueInput[] | VariationWhereUniqueInput>;
  set?: Maybe<VariationWhereUniqueInput[] | VariationWhereUniqueInput>;
  disconnect?: Maybe<VariationWhereUniqueInput[] | VariationWhereUniqueInput>;
  update?: Maybe<
    | VariationUpdateWithWhereUniqueWithoutTestInput[]
    | VariationUpdateWithWhereUniqueWithoutTestInput
  >;
  upsert?: Maybe<
    | VariationUpsertWithWhereUniqueWithoutTestInput[]
    | VariationUpsertWithWhereUniqueWithoutTestInput
  >;
  deleteMany?: Maybe<VariationScalarWhereInput[] | VariationScalarWhereInput>;
  updateMany?: Maybe<
    | VariationUpdateManyWithWhereNestedInput[]
    | VariationUpdateManyWithWhereNestedInput
  >;
}

export type TestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface VariationUpdateWithWhereUniqueWithoutTestInput {
  where: VariationWhereUniqueInput;
  data: VariationUpdateWithoutTestDataInput;
}

export interface TestUpdateInput {
  name?: Maybe<String>;
  project?: Maybe<ProjectUpdateOneWithoutTestsInput>;
  variations?: Maybe<VariationUpdateManyWithoutTestInput>;
}

export interface VariationUpdateWithoutTestDataInput {
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  testSessions?: Maybe<TestSessionUpdateManyWithoutVariationInput>;
  baselineVariationRef?: Maybe<TestSessionUpdateOneWithoutBaselineRefInput>;
}

export type TestSessionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TestSessionUpdateManyWithoutVariationInput {
  create?: Maybe<
    | TestSessionCreateWithoutVariationInput[]
    | TestSessionCreateWithoutVariationInput
  >;
  delete?: Maybe<TestSessionWhereUniqueInput[] | TestSessionWhereUniqueInput>;
  connect?: Maybe<TestSessionWhereUniqueInput[] | TestSessionWhereUniqueInput>;
  set?: Maybe<TestSessionWhereUniqueInput[] | TestSessionWhereUniqueInput>;
  disconnect?: Maybe<
    TestSessionWhereUniqueInput[] | TestSessionWhereUniqueInput
  >;
  update?: Maybe<
    | TestSessionUpdateWithWhereUniqueWithoutVariationInput[]
    | TestSessionUpdateWithWhereUniqueWithoutVariationInput
  >;
  upsert?: Maybe<
    | TestSessionUpsertWithWhereUniqueWithoutVariationInput[]
    | TestSessionUpsertWithWhereUniqueWithoutVariationInput
  >;
  deleteMany?: Maybe<
    TestSessionScalarWhereInput[] | TestSessionScalarWhereInput
  >;
  updateMany?: Maybe<
    | TestSessionUpdateManyWithWhereNestedInput[]
    | TestSessionUpdateManyWithWhereNestedInput
  >;
}

export interface RefreshTokenListUpdateInput {
  refreshToken?: Maybe<String>;
}

export interface VariationUpdateManyWithWhereNestedInput {
  where: VariationScalarWhereInput;
  data: VariationUpdateManyDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
  apiKey?: Maybe<String>;
}>;

export interface TestSessionUpdateWithoutVariationDataInput {
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  baselineForDiffRef?: Maybe<TestSessionUpdateOneWithoutDiffBaselineInput>;
  baselineRef?: Maybe<VariationUpdateOneWithoutBaselineVariationRefInput>;
  diffBaseline?: Maybe<TestSessionUpdateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserUpdateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface TestUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TestSessionUpdateOneWithoutDiffBaselineInput {
  create?: Maybe<TestSessionCreateWithoutDiffBaselineInput>;
  update?: Maybe<TestSessionUpdateWithoutDiffBaselineDataInput>;
  upsert?: Maybe<TestSessionUpsertWithoutDiffBaselineInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TestSessionWhereUniqueInput>;
}

export type VariationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TestSessionUpdateWithoutDiffBaselineDataInput {
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationUpdateOneWithoutTestSessionsInput>;
  baselineForDiffRef?: Maybe<TestSessionUpdateOneWithoutDiffBaselineInput>;
  baselineRef?: Maybe<VariationUpdateOneWithoutBaselineVariationRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserUpdateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface TestUpsertWithWhereUniqueWithoutProjectInput {
  where: TestWhereUniqueInput;
  update: TestUpdateWithoutProjectDataInput;
  create: TestCreateWithoutProjectInput;
}

export interface VariationUpdateOneWithoutTestSessionsInput {
  create?: Maybe<VariationCreateWithoutTestSessionsInput>;
  update?: Maybe<VariationUpdateWithoutTestSessionsDataInput>;
  upsert?: Maybe<VariationUpsertWithoutTestSessionsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VariationWhereUniqueInput>;
}

export interface TestCreateManyWithoutProjectInput {
  create?: Maybe<
    TestCreateWithoutProjectInput[] | TestCreateWithoutProjectInput
  >;
  connect?: Maybe<TestWhereUniqueInput[] | TestWhereUniqueInput>;
}

export interface VariationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  browserName?: Maybe<String>;
  browserName_not?: Maybe<String>;
  browserName_in?: Maybe<String[] | String>;
  browserName_not_in?: Maybe<String[] | String>;
  browserName_lt?: Maybe<String>;
  browserName_lte?: Maybe<String>;
  browserName_gt?: Maybe<String>;
  browserName_gte?: Maybe<String>;
  browserName_contains?: Maybe<String>;
  browserName_not_contains?: Maybe<String>;
  browserName_starts_with?: Maybe<String>;
  browserName_not_starts_with?: Maybe<String>;
  browserName_ends_with?: Maybe<String>;
  browserName_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  deviceName?: Maybe<String>;
  deviceName_not?: Maybe<String>;
  deviceName_in?: Maybe<String[] | String>;
  deviceName_not_in?: Maybe<String[] | String>;
  deviceName_lt?: Maybe<String>;
  deviceName_lte?: Maybe<String>;
  deviceName_gt?: Maybe<String>;
  deviceName_gte?: Maybe<String>;
  deviceName_contains?: Maybe<String>;
  deviceName_not_contains?: Maybe<String>;
  deviceName_starts_with?: Maybe<String>;
  deviceName_not_starts_with?: Maybe<String>;
  deviceName_ends_with?: Maybe<String>;
  deviceName_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<VariationScalarWhereInput[] | VariationScalarWhereInput>;
  OR?: Maybe<VariationScalarWhereInput[] | VariationScalarWhereInput>;
  NOT?: Maybe<VariationScalarWhereInput[] | VariationScalarWhereInput>;
}

export interface VariationCreateManyWithoutTestInput {
  create?: Maybe<
    VariationCreateWithoutTestInput[] | VariationCreateWithoutTestInput
  >;
  connect?: Maybe<VariationWhereUniqueInput[] | VariationWhereUniqueInput>;
}

export interface VariationUpsertWithWhereUniqueWithoutTestInput {
  where: VariationWhereUniqueInput;
  update: VariationUpdateWithoutTestDataInput;
  create: VariationCreateWithoutTestInput;
}

export interface TestSessionCreateManyWithoutVariationInput {
  create?: Maybe<
    | TestSessionCreateWithoutVariationInput[]
    | TestSessionCreateWithoutVariationInput
  >;
  connect?: Maybe<TestSessionWhereUniqueInput[] | TestSessionWhereUniqueInput>;
}

export interface TestSessionUpdateManyDataInput {
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  state?: Maybe<TestSessionState>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface TestSessionCreateOneWithoutDiffBaselineInput {
  create?: Maybe<TestSessionCreateWithoutDiffBaselineInput>;
  connect?: Maybe<TestSessionWhereUniqueInput>;
}

export interface ProjectUpdateOneWithoutTestsInput {
  create?: Maybe<ProjectCreateWithoutTestsInput>;
  update?: Maybe<ProjectUpdateWithoutTestsDataInput>;
  upsert?: Maybe<ProjectUpsertWithoutTestsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface VariationCreateOneWithoutTestSessionsInput {
  create?: Maybe<VariationCreateWithoutTestSessionsInput>;
  connect?: Maybe<VariationWhereUniqueInput>;
}

export interface ProjectUpdateWithoutTestsDataInput {
  name?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutProjectsInput>;
  description?: Maybe<String>;
}

export interface TestCreateOneWithoutVariationsInput {
  create?: Maybe<TestCreateWithoutVariationsInput>;
  connect?: Maybe<TestWhereUniqueInput>;
}

export interface UserUpdateManyWithoutProjectsInput {
  create?: Maybe<
    UserCreateWithoutProjectsInput[] | UserCreateWithoutProjectsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutProjectsInput[]
    | UserUpdateWithWhereUniqueWithoutProjectsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutProjectsInput[]
    | UserUpsertWithWhereUniqueWithoutProjectsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface ProjectCreateOneWithoutTestsInput {
  create?: Maybe<ProjectCreateWithoutTestsInput>;
  connect?: Maybe<ProjectWhereUniqueInput>;
}

export interface UserUpdateWithWhereUniqueWithoutProjectsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutProjectsDataInput;
}

export interface UserCreateManyWithoutProjectsInput {
  create?: Maybe<
    UserCreateWithoutProjectsInput[] | UserCreateWithoutProjectsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserUpdateWithoutProjectsDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  lastname?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  forename?: Maybe<String>;
  active?: Maybe<Boolean>;
  role?: Maybe<Role>;
  apiKey?: Maybe<String>;
}

export interface TestSessionCreateOneWithoutBaselineRefInput {
  create?: Maybe<TestSessionCreateWithoutBaselineRefInput>;
  connect?: Maybe<TestSessionWhereUniqueInput>;
}

export interface UserUpsertWithWhereUniqueWithoutProjectsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutProjectsDataInput;
  create: UserCreateWithoutProjectsInput;
}

export interface TestSessionCreateOneWithoutBaselineForDiffRefInput {
  create?: Maybe<TestSessionCreateWithoutBaselineForDiffRefInput>;
  connect?: Maybe<TestSessionWhereUniqueInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  forename?: Maybe<String>;
  forename_not?: Maybe<String>;
  forename_in?: Maybe<String[] | String>;
  forename_not_in?: Maybe<String[] | String>;
  forename_lt?: Maybe<String>;
  forename_lte?: Maybe<String>;
  forename_gt?: Maybe<String>;
  forename_gte?: Maybe<String>;
  forename_contains?: Maybe<String>;
  forename_not_contains?: Maybe<String>;
  forename_starts_with?: Maybe<String>;
  forename_not_starts_with?: Maybe<String>;
  forename_ends_with?: Maybe<String>;
  forename_not_ends_with?: Maybe<String>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface TestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  project?: Maybe<ProjectWhereInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  variations_every?: Maybe<VariationWhereInput>;
  variations_some?: Maybe<VariationWhereInput>;
  variations_none?: Maybe<VariationWhereInput>;
  AND?: Maybe<TestWhereInput[] | TestWhereInput>;
  OR?: Maybe<TestWhereInput[] | TestWhereInput>;
  NOT?: Maybe<TestWhereInput[] | TestWhereInput>;
}

export interface UserUpdateManyDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  lastname?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  forename?: Maybe<String>;
  active?: Maybe<Boolean>;
  role?: Maybe<Role>;
  apiKey?: Maybe<String>;
}

export interface VariationUpdateInput {
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  test?: Maybe<TestUpdateOneWithoutVariationsInput>;
  testSessions?: Maybe<TestSessionUpdateManyWithoutVariationInput>;
  baselineVariationRef?: Maybe<TestSessionUpdateOneWithoutBaselineRefInput>;
}

export interface ProjectUpsertWithoutTestsInput {
  update: ProjectUpdateWithoutTestsDataInput;
  create: ProjectCreateWithoutTestsInput;
}

export interface RefreshTokenListWhereInput {
  userId?: Maybe<ID_Input>;
  userId_not?: Maybe<ID_Input>;
  userId_in?: Maybe<ID_Input[] | ID_Input>;
  userId_not_in?: Maybe<ID_Input[] | ID_Input>;
  userId_lt?: Maybe<ID_Input>;
  userId_lte?: Maybe<ID_Input>;
  userId_gt?: Maybe<ID_Input>;
  userId_gte?: Maybe<ID_Input>;
  userId_contains?: Maybe<ID_Input>;
  userId_not_contains?: Maybe<ID_Input>;
  userId_starts_with?: Maybe<ID_Input>;
  userId_not_starts_with?: Maybe<ID_Input>;
  userId_ends_with?: Maybe<ID_Input>;
  userId_not_ends_with?: Maybe<ID_Input>;
  refreshToken?: Maybe<String>;
  refreshToken_not?: Maybe<String>;
  refreshToken_in?: Maybe<String[] | String>;
  refreshToken_not_in?: Maybe<String[] | String>;
  refreshToken_lt?: Maybe<String>;
  refreshToken_lte?: Maybe<String>;
  refreshToken_gt?: Maybe<String>;
  refreshToken_gte?: Maybe<String>;
  refreshToken_contains?: Maybe<String>;
  refreshToken_not_contains?: Maybe<String>;
  refreshToken_starts_with?: Maybe<String>;
  refreshToken_not_starts_with?: Maybe<String>;
  refreshToken_ends_with?: Maybe<String>;
  refreshToken_not_ends_with?: Maybe<String>;
  AND?: Maybe<RefreshTokenListWhereInput[] | RefreshTokenListWhereInput>;
  OR?: Maybe<RefreshTokenListWhereInput[] | RefreshTokenListWhereInput>;
  NOT?: Maybe<RefreshTokenListWhereInput[] | RefreshTokenListWhereInput>;
}

export interface TestUpsertWithoutVariationsInput {
  update: TestUpdateWithoutVariationsDataInput;
  create: TestCreateWithoutVariationsInput;
}

export interface TestSessionCreateInput {
  id?: Maybe<ID_Input>;
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance: Float;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationCreateOneWithoutTestSessionsInput>;
  baselineForDiffRef?: Maybe<TestSessionCreateOneWithoutDiffBaselineInput>;
  baselineRef?: Maybe<VariationCreateOneWithoutBaselineVariationRefInput>;
  diffBaseline?: Maybe<TestSessionCreateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserCreateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface TestSessionUpdateOneWithoutBaselineRefInput {
  create?: Maybe<TestSessionCreateWithoutBaselineRefInput>;
  update?: Maybe<TestSessionUpdateWithoutBaselineRefDataInput>;
  upsert?: Maybe<TestSessionUpsertWithoutBaselineRefInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TestSessionWhereUniqueInput>;
}

export interface TestCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  project?: Maybe<ProjectCreateOneWithoutTestsInput>;
  variations?: Maybe<VariationCreateManyWithoutTestInput>;
}

export interface TestSessionUpdateWithoutBaselineRefDataInput {
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationUpdateOneWithoutTestSessionsInput>;
  baselineForDiffRef?: Maybe<TestSessionUpdateOneWithoutDiffBaselineInput>;
  diffBaseline?: Maybe<TestSessionUpdateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserUpdateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface RefreshTokenListCreateInput {
  userId?: Maybe<ID_Input>;
  refreshToken: String;
}

export interface TestSessionUpdateOneWithoutBaselineForDiffRefInput {
  create?: Maybe<TestSessionCreateWithoutBaselineForDiffRefInput>;
  update?: Maybe<TestSessionUpdateWithoutBaselineForDiffRefDataInput>;
  upsert?: Maybe<TestSessionUpsertWithoutBaselineForDiffRefInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TestSessionWhereUniqueInput>;
}

export interface TestUpdateManyWithWhereNestedInput {
  where: TestScalarWhereInput;
  data: TestUpdateManyDataInput;
}

export interface TestSessionUpdateWithoutBaselineForDiffRefDataInput {
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationUpdateOneWithoutTestSessionsInput>;
  baselineRef?: Maybe<VariationUpdateOneWithoutBaselineVariationRefInput>;
  diffBaseline?: Maybe<TestSessionUpdateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserUpdateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface VariationUpdateManyDataInput {
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
}

export interface VariationUpdateOneWithoutBaselineVariationRefInput {
  create?: Maybe<VariationCreateWithoutBaselineVariationRefInput>;
  update?: Maybe<VariationUpdateWithoutBaselineVariationRefDataInput>;
  upsert?: Maybe<VariationUpsertWithoutBaselineVariationRefInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VariationWhereUniqueInput>;
}

export interface TestCreateWithoutProjectInput {
  id?: Maybe<ID_Input>;
  name: String;
  variations?: Maybe<VariationCreateManyWithoutTestInput>;
}

export interface VariationUpdateWithoutBaselineVariationRefDataInput {
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  test?: Maybe<TestUpdateOneWithoutVariationsInput>;
  testSessions?: Maybe<TestSessionUpdateManyWithoutVariationInput>;
}

export interface TestSessionCreateWithoutVariationInput {
  id?: Maybe<ID_Input>;
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance: Float;
  isSameDimensions?: Maybe<Boolean>;
  baselineForDiffRef?: Maybe<TestSessionCreateOneWithoutDiffBaselineInput>;
  baselineRef?: Maybe<VariationCreateOneWithoutBaselineVariationRefInput>;
  diffBaseline?: Maybe<TestSessionCreateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserCreateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface VariationUpsertWithoutBaselineVariationRefInput {
  update: VariationUpdateWithoutBaselineVariationRefDataInput;
  create: VariationCreateWithoutBaselineVariationRefInput;
}

export interface VariationCreateWithoutTestSessionsInput {
  id?: Maybe<ID_Input>;
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  test?: Maybe<TestCreateOneWithoutVariationsInput>;
  baselineVariationRef?: Maybe<TestSessionCreateOneWithoutBaselineRefInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ProjectCreateWithoutTestsInput {
  id?: Maybe<ID_Input>;
  name: String;
  users?: Maybe<UserCreateManyWithoutProjectsInput>;
  description?: Maybe<String>;
}

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  lastname?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  forename?: Maybe<String>;
  active?: Maybe<Boolean>;
  role?: Maybe<Role>;
  projects?: Maybe<ProjectUpdateManyWithoutUsersInput>;
  apiKey?: Maybe<String>;
}

export interface TestSessionCreateWithoutBaselineRefInput {
  id?: Maybe<ID_Input>;
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance: Float;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationCreateOneWithoutTestSessionsInput>;
  baselineForDiffRef?: Maybe<TestSessionCreateOneWithoutDiffBaselineInput>;
  diffBaseline?: Maybe<TestSessionCreateOneWithoutBaselineForDiffRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserCreateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface ProjectUpdateManyWithoutUsersInput {
  create?: Maybe<
    ProjectCreateWithoutUsersInput[] | ProjectCreateWithoutUsersInput
  >;
  delete?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  connect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  set?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  disconnect?: Maybe<ProjectWhereUniqueInput[] | ProjectWhereUniqueInput>;
  update?: Maybe<
    | ProjectUpdateWithWhereUniqueWithoutUsersInput[]
    | ProjectUpdateWithWhereUniqueWithoutUsersInput
  >;
  upsert?: Maybe<
    | ProjectUpsertWithWhereUniqueWithoutUsersInput[]
    | ProjectUpsertWithWhereUniqueWithoutUsersInput
  >;
  deleteMany?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  updateMany?: Maybe<
    | ProjectUpdateManyWithWhereNestedInput[]
    | ProjectUpdateManyWithWhereNestedInput
  >;
}

export interface TestSessionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TestSessionWhereInput>;
  AND?: Maybe<
    TestSessionSubscriptionWhereInput[] | TestSessionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TestSessionSubscriptionWhereInput[] | TestSessionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TestSessionSubscriptionWhereInput[] | TestSessionSubscriptionWhereInput
  >;
}

export interface ProjectUpdateWithWhereUniqueWithoutUsersInput {
  where: ProjectWhereUniqueInput;
  data: ProjectUpdateWithoutUsersDataInput;
}

export type RefreshTokenListWhereUniqueInput = AtLeastOne<{
  userId: Maybe<ID_Input>;
  refreshToken?: Maybe<String>;
}>;

export interface ProjectUpdateWithoutUsersDataInput {
  name?: Maybe<String>;
  tests?: Maybe<TestUpdateManyWithoutProjectInput>;
  description?: Maybe<String>;
}

export interface TestUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ProjectUpsertWithWhereUniqueWithoutUsersInput {
  where: ProjectWhereUniqueInput;
  update: ProjectUpdateWithoutUsersDataInput;
  create: ProjectCreateWithoutUsersInput;
}

export interface ProjectUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ProjectScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  OR?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
  NOT?: Maybe<ProjectScalarWhereInput[] | ProjectScalarWhereInput>;
}

export interface ProjectCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  tests?: Maybe<TestCreateManyWithoutProjectInput>;
  users?: Maybe<UserCreateManyWithoutProjectsInput>;
  description?: Maybe<String>;
}

export interface ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput;
  data: ProjectUpdateManyDataInput;
}

export interface TestSessionCreateWithoutDiffBaselineInput {
  id?: Maybe<ID_Input>;
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance: Float;
  isSameDimensions?: Maybe<Boolean>;
  variation?: Maybe<VariationCreateOneWithoutTestSessionsInput>;
  baselineForDiffRef?: Maybe<TestSessionCreateOneWithoutDiffBaselineInput>;
  baselineRef?: Maybe<VariationCreateOneWithoutBaselineVariationRefInput>;
  state?: Maybe<TestSessionState>;
  stateChangedByUser?: Maybe<UserCreateOneInput>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface ProjectUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserCreateWithoutProjectsInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  lastname?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  forename?: Maybe<String>;
  active?: Maybe<Boolean>;
  role?: Maybe<Role>;
  apiKey: String;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProjectWhereInput>;
  AND?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  OR?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
  NOT?: Maybe<ProjectSubscriptionWhereInput[] | ProjectSubscriptionWhereInput>;
}

export interface TestSessionUpsertWithoutBaselineForDiffRefInput {
  update: TestSessionUpdateWithoutBaselineForDiffRefDataInput;
  create: TestSessionCreateWithoutBaselineForDiffRefInput;
}

export interface RefreshTokenListUpdateManyMutationInput {
  refreshToken?: Maybe<String>;
}

export interface TestSessionUpsertWithoutBaselineRefInput {
  update: TestSessionUpdateWithoutBaselineRefDataInput;
  create: TestSessionCreateWithoutBaselineRefInput;
}

export interface VariationCreateWithoutTestInput {
  id?: Maybe<ID_Input>;
  additionalData?: Maybe<Json>;
  browserName?: Maybe<String>;
  deviceName?: Maybe<String>;
  testSessions?: Maybe<TestSessionCreateManyWithoutVariationInput>;
  baselineVariationRef?: Maybe<TestSessionCreateOneWithoutBaselineRefInput>;
}

export interface TestSessionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  diffImageKey?: Maybe<String>;
  diffImageKey_not?: Maybe<String>;
  diffImageKey_in?: Maybe<String[] | String>;
  diffImageKey_not_in?: Maybe<String[] | String>;
  diffImageKey_lt?: Maybe<String>;
  diffImageKey_lte?: Maybe<String>;
  diffImageKey_gt?: Maybe<String>;
  diffImageKey_gte?: Maybe<String>;
  diffImageKey_contains?: Maybe<String>;
  diffImageKey_not_contains?: Maybe<String>;
  diffImageKey_starts_with?: Maybe<String>;
  diffImageKey_not_starts_with?: Maybe<String>;
  diffImageKey_ends_with?: Maybe<String>;
  diffImageKey_not_ends_with?: Maybe<String>;
  imageKey?: Maybe<String>;
  imageKey_not?: Maybe<String>;
  imageKey_in?: Maybe<String[] | String>;
  imageKey_not_in?: Maybe<String[] | String>;
  imageKey_lt?: Maybe<String>;
  imageKey_lte?: Maybe<String>;
  imageKey_gt?: Maybe<String>;
  imageKey_gte?: Maybe<String>;
  imageKey_contains?: Maybe<String>;
  imageKey_not_contains?: Maybe<String>;
  imageKey_starts_with?: Maybe<String>;
  imageKey_not_starts_with?: Maybe<String>;
  imageKey_ends_with?: Maybe<String>;
  imageKey_not_ends_with?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchPercentage_not?: Maybe<Float>;
  misMatchPercentage_in?: Maybe<Float[] | Float>;
  misMatchPercentage_not_in?: Maybe<Float[] | Float>;
  misMatchPercentage_lt?: Maybe<Float>;
  misMatchPercentage_lte?: Maybe<Float>;
  misMatchPercentage_gt?: Maybe<Float>;
  misMatchPercentage_gte?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  misMatchTolerance_not?: Maybe<Float>;
  misMatchTolerance_in?: Maybe<Float[] | Float>;
  misMatchTolerance_not_in?: Maybe<Float[] | Float>;
  misMatchTolerance_lt?: Maybe<Float>;
  misMatchTolerance_lte?: Maybe<Float>;
  misMatchTolerance_gt?: Maybe<Float>;
  misMatchTolerance_gte?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  isSameDimensions_not?: Maybe<Boolean>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  state?: Maybe<TestSessionState>;
  state_not?: Maybe<TestSessionState>;
  state_in?: Maybe<TestSessionState[] | TestSessionState>;
  state_not_in?: Maybe<TestSessionState[] | TestSessionState>;
  stateComment?: Maybe<String>;
  stateComment_not?: Maybe<String>;
  stateComment_in?: Maybe<String[] | String>;
  stateComment_not_in?: Maybe<String[] | String>;
  stateComment_lt?: Maybe<String>;
  stateComment_lte?: Maybe<String>;
  stateComment_gt?: Maybe<String>;
  stateComment_gte?: Maybe<String>;
  stateComment_contains?: Maybe<String>;
  stateComment_not_contains?: Maybe<String>;
  stateComment_starts_with?: Maybe<String>;
  stateComment_not_starts_with?: Maybe<String>;
  stateComment_ends_with?: Maybe<String>;
  stateComment_not_ends_with?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
  autoBaseline_not?: Maybe<Boolean>;
  AND?: Maybe<TestSessionScalarWhereInput[] | TestSessionScalarWhereInput>;
  OR?: Maybe<TestSessionScalarWhereInput[] | TestSessionScalarWhereInput>;
  NOT?: Maybe<TestSessionScalarWhereInput[] | TestSessionScalarWhereInput>;
}

export interface TestSessionUpsertWithWhereUniqueWithoutVariationInput {
  where: TestSessionWhereUniqueInput;
  update: TestSessionUpdateWithoutVariationDataInput;
  create: TestSessionCreateWithoutVariationInput;
}

export interface TestSessionUpsertWithoutDiffBaselineInput {
  update: TestSessionUpdateWithoutDiffBaselineDataInput;
  create: TestSessionCreateWithoutDiffBaselineInput;
}

export interface VariationUpsertWithoutTestSessionsInput {
  update: VariationUpdateWithoutTestSessionsDataInput;
  create: VariationCreateWithoutTestSessionsInput;
}

export interface TestCreateWithoutVariationsInput {
  id?: Maybe<ID_Input>;
  name: String;
  project?: Maybe<ProjectCreateOneWithoutTestsInput>;
}

export interface TestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>;
  OR?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>;
  NOT?: Maybe<TestScalarWhereInput[] | TestScalarWhereInput>;
}

export interface TestSessionUpdateManyMutationInput {
  diffImageKey?: Maybe<String>;
  imageKey?: Maybe<String>;
  misMatchPercentage?: Maybe<Float>;
  misMatchTolerance?: Maybe<Float>;
  isSameDimensions?: Maybe<Boolean>;
  state?: Maybe<TestSessionState>;
  stateComment?: Maybe<String>;
  autoBaseline?: Maybe<Boolean>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  lastname?: Maybe<String>;
  lastname_not?: Maybe<String>;
  lastname_in?: Maybe<String[] | String>;
  lastname_not_in?: Maybe<String[] | String>;
  lastname_lt?: Maybe<String>;
  lastname_lte?: Maybe<String>;
  lastname_gt?: Maybe<String>;
  lastname_gte?: Maybe<String>;
  lastname_contains?: Maybe<String>;
  lastname_not_contains?: Maybe<String>;
  lastname_starts_with?: Maybe<String>;
  lastname_not_starts_with?: Maybe<String>;
  lastname_ends_with?: Maybe<String>;
  lastname_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  forename?: Maybe<String>;
  forename_not?: Maybe<String>;
  forename_in?: Maybe<String[] | String>;
  forename_not_in?: Maybe<String[] | String>;
  forename_lt?: Maybe<String>;
  forename_lte?: Maybe<String>;
  forename_gt?: Maybe<String>;
  forename_gte?: Maybe<String>;
  forename_contains?: Maybe<String>;
  forename_not_contains?: Maybe<String>;
  forename_starts_with?: Maybe<String>;
  forename_not_starts_with?: Maybe<String>;
  forename_ends_with?: Maybe<String>;
  forename_not_ends_with?: Maybe<String>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  projects_every?: Maybe<ProjectWhereInput>;
  projects_some?: Maybe<ProjectWhereInput>;
  projects_none?: Maybe<ProjectWhereInput>;
  apiKey?: Maybe<String>;
  apiKey_not?: Maybe<String>;
  apiKey_in?: Maybe<String[] | String>;
  apiKey_not_in?: Maybe<String[] | String>;
  apiKey_lt?: Maybe<String>;
  apiKey_lte?: Maybe<String>;
  apiKey_gt?: Maybe<String>;
  apiKey_gte?: Maybe<String>;
  apiKey_contains?: Maybe<String>;
  apiKey_not_contains?: Maybe<String>;
  apiKey_starts_with?: Maybe<String>;
  apiKey_not_starts_with?: Maybe<String>;
  apiKey_ends_with?: Maybe<String>;
  apiKey_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VariationPreviousValues {
  id: ID_Output;
  additionalData?: Json;
  browserName?: String;
  createdAt: DateTimeOutput;
  deviceName?: String;
  updatedAt: DateTimeOutput;
}

export interface VariationPreviousValuesPromise
  extends Promise<VariationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  additionalData: () => Promise<Json>;
  browserName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deviceName: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface VariationPreviousValuesSubscription
  extends Promise<AsyncIterator<VariationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  additionalData: () => Promise<AsyncIterator<Json>>;
  browserName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deviceName: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface RefreshTokenList {
  userId: ID_Output;
  refreshToken: String;
}

export interface RefreshTokenListPromise
  extends Promise<RefreshTokenList>,
    Fragmentable {
  userId: () => Promise<ID_Output>;
  refreshToken: () => Promise<String>;
}

export interface RefreshTokenListSubscription
  extends Promise<AsyncIterator<RefreshTokenList>>,
    Fragmentable {
  userId: () => Promise<AsyncIterator<ID_Output>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
}

export interface RefreshTokenListNullablePromise
  extends Promise<RefreshTokenList | null>,
    Fragmentable {
  userId: () => Promise<ID_Output>;
  refreshToken: () => Promise<String>;
}

export interface Test {
  id: ID_Output;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface TestPromise extends Promise<Test>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  project: <T = ProjectPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  variations: <T = FragmentableArray<Variation>>(args?: {
    where?: VariationWhereInput;
    orderBy?: VariationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TestSubscription
  extends Promise<AsyncIterator<Test>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  project: <T = ProjectSubscription>() => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  variations: <T = Promise<AsyncIterator<VariationSubscription>>>(args?: {
    where?: VariationWhereInput;
    orderBy?: VariationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TestNullablePromise
  extends Promise<Test | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  project: <T = ProjectPromise>() => T;
  updatedAt: () => Promise<DateTimeOutput>;
  variations: <T = FragmentableArray<Variation>>(args?: {
    where?: VariationWhereInput;
    orderBy?: VariationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RefreshTokenListConnection {
  pageInfo: PageInfo;
  edges: RefreshTokenListEdge[];
}

export interface RefreshTokenListConnectionPromise
  extends Promise<RefreshTokenListConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RefreshTokenListEdge>>() => T;
  aggregate: <T = AggregateRefreshTokenListPromise>() => T;
}

export interface RefreshTokenListConnectionSubscription
  extends Promise<AsyncIterator<RefreshTokenListConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RefreshTokenListEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRefreshTokenListSubscription>() => T;
}

export interface TestSessionSubscriptionPayload {
  mutation: MutationType;
  node: TestSession;
  updatedFields: String[];
  previousValues: TestSessionPreviousValues;
}

export interface TestSessionSubscriptionPayloadPromise
  extends Promise<TestSessionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestSessionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestSessionPreviousValuesPromise>() => T;
}

export interface TestSessionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestSessionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestSessionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestSessionPreviousValuesSubscription>() => T;
}

export interface Variation {
  id: ID_Output;
  additionalData?: Json;
  browserName?: String;
  createdAt: DateTimeOutput;
  deviceName?: String;
  updatedAt: DateTimeOutput;
}

export interface VariationPromise extends Promise<Variation>, Fragmentable {
  id: () => Promise<ID_Output>;
  additionalData: () => Promise<Json>;
  browserName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deviceName: () => Promise<String>;
  test: <T = TestPromise>() => T;
  testSessions: <T = FragmentableArray<TestSession>>(args?: {
    where?: TestSessionWhereInput;
    orderBy?: TestSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  baselineVariationRef: <T = TestSessionPromise>() => T;
}

export interface VariationSubscription
  extends Promise<AsyncIterator<Variation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  additionalData: () => Promise<AsyncIterator<Json>>;
  browserName: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  deviceName: () => Promise<AsyncIterator<String>>;
  test: <T = TestSubscription>() => T;
  testSessions: <T = Promise<AsyncIterator<TestSessionSubscription>>>(args?: {
    where?: TestSessionWhereInput;
    orderBy?: TestSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  baselineVariationRef: <T = TestSessionSubscription>() => T;
}

export interface VariationNullablePromise
  extends Promise<Variation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  additionalData: () => Promise<Json>;
  browserName: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  deviceName: () => Promise<String>;
  test: <T = TestPromise>() => T;
  testSessions: <T = FragmentableArray<TestSession>>(args?: {
    where?: TestSessionWhereInput;
    orderBy?: TestSessionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  baselineVariationRef: <T = TestSessionPromise>() => T;
}

export interface AggregateProject {
  count: Int;
}

export interface AggregateProjectPromise
  extends Promise<AggregateProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProjectSubscription
  extends Promise<AsyncIterator<AggregateProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  lastname?: String;
  phoneNumber?: String;
  forename?: String;
  active: Boolean;
  role: Role;
  apiKey: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lastname: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  forename: () => Promise<String>;
  active: () => Promise<Boolean>;
  role: () => Promise<Role>;
  apiKey: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastname: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  forename: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  role: () => Promise<AsyncIterator<Role>>;
  apiKey: () => Promise<AsyncIterator<String>>;
}

export interface VariationEdge {
  node: Variation;
  cursor: String;
}

export interface VariationEdgePromise
  extends Promise<VariationEdge>,
    Fragmentable {
  node: <T = VariationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VariationEdgeSubscription
  extends Promise<AsyncIterator<VariationEdge>>,
    Fragmentable {
  node: <T = VariationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectEdge {
  node: Project;
  cursor: String;
}

export interface ProjectEdgePromise extends Promise<ProjectEdge>, Fragmentable {
  node: <T = ProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProjectEdgeSubscription
  extends Promise<AsyncIterator<ProjectEdge>>,
    Fragmentable {
  node: <T = ProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface VariationSubscriptionPayload {
  mutation: MutationType;
  node: Variation;
  updatedFields: String[];
  previousValues: VariationPreviousValues;
}

export interface VariationSubscriptionPayloadPromise
  extends Promise<VariationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VariationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VariationPreviousValuesPromise>() => T;
}

export interface VariationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VariationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VariationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VariationPreviousValuesSubscription>() => T;
}

export interface ProjectConnection {
  pageInfo: PageInfo;
  edges: ProjectEdge[];
}

export interface ProjectConnectionPromise
  extends Promise<ProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProjectEdge>>() => T;
  aggregate: <T = AggregateProjectPromise>() => T;
}

export interface ProjectConnectionSubscription
  extends Promise<AsyncIterator<ProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProjectSubscription>() => T;
}

export interface TestSessionEdge {
  node: TestSession;
  cursor: String;
}

export interface TestSessionEdgePromise
  extends Promise<TestSessionEdge>,
    Fragmentable {
  node: <T = TestSessionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestSessionEdgeSubscription
  extends Promise<AsyncIterator<TestSessionEdge>>,
    Fragmentable {
  node: <T = TestSessionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Project {
  id: ID_Output;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ProjectPromise extends Promise<Project>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  tests: <T = FragmentableArray<Test>>(args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<String>;
}

export interface ProjectSubscription
  extends Promise<AsyncIterator<Project>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  tests: <T = Promise<AsyncIterator<TestSubscription>>>(args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProjectNullablePromise
  extends Promise<Project | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  tests: <T = FragmentableArray<Test>>(args?: {
    where?: TestWhereInput;
    orderBy?: TestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  updatedAt: () => Promise<DateTimeOutput>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  description: () => Promise<String>;
}

export interface AggregateTest {
  count: Int;
}

export interface AggregateTestPromise
  extends Promise<AggregateTest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestSubscription
  extends Promise<AsyncIterator<AggregateTest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProjectSubscriptionPayload {
  mutation: MutationType;
  node: Project;
  updatedFields: String[];
  previousValues: ProjectPreviousValues;
}

export interface ProjectSubscriptionPayloadPromise
  extends Promise<ProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProjectPreviousValuesPromise>() => T;
}

export interface ProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProjectPreviousValuesSubscription>() => T;
}

export interface TestConnection {
  pageInfo: PageInfo;
  edges: TestEdge[];
}

export interface TestConnectionPromise
  extends Promise<TestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestEdge>>() => T;
  aggregate: <T = AggregateTestPromise>() => T;
}

export interface TestConnectionSubscription
  extends Promise<AsyncIterator<TestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestSubscription>() => T;
}

export interface ProjectPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ProjectPreviousValuesPromise
  extends Promise<ProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
}

export interface ProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<ProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface RefreshTokenListEdge {
  node: RefreshTokenList;
  cursor: String;
}

export interface RefreshTokenListEdgePromise
  extends Promise<RefreshTokenListEdge>,
    Fragmentable {
  node: <T = RefreshTokenListPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RefreshTokenListEdgeSubscription
  extends Promise<AsyncIterator<RefreshTokenListEdge>>,
    Fragmentable {
  node: <T = RefreshTokenListSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TestSessionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  diffImageKey?: String;
  imageKey?: String;
  misMatchPercentage?: Float;
  misMatchTolerance: Float;
  isSameDimensions?: Boolean;
  updatedAt: DateTimeOutput;
  state: TestSessionState;
  stateComment?: String;
  autoBaseline: Boolean;
}

export interface TestSessionPreviousValuesPromise
  extends Promise<TestSessionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  diffImageKey: () => Promise<String>;
  imageKey: () => Promise<String>;
  misMatchPercentage: () => Promise<Float>;
  misMatchTolerance: () => Promise<Float>;
  isSameDimensions: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  state: () => Promise<TestSessionState>;
  stateComment: () => Promise<String>;
  autoBaseline: () => Promise<Boolean>;
}

export interface TestSessionPreviousValuesSubscription
  extends Promise<AsyncIterator<TestSessionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  diffImageKey: () => Promise<AsyncIterator<String>>;
  imageKey: () => Promise<AsyncIterator<String>>;
  misMatchPercentage: () => Promise<AsyncIterator<Float>>;
  misMatchTolerance: () => Promise<AsyncIterator<Float>>;
  isSameDimensions: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  state: () => Promise<AsyncIterator<TestSessionState>>;
  stateComment: () => Promise<AsyncIterator<String>>;
  autoBaseline: () => Promise<AsyncIterator<Boolean>>;
}

export interface VariationConnection {
  pageInfo: PageInfo;
  edges: VariationEdge[];
}

export interface VariationConnectionPromise
  extends Promise<VariationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VariationEdge>>() => T;
  aggregate: <T = AggregateVariationPromise>() => T;
}

export interface VariationConnectionSubscription
  extends Promise<AsyncIterator<VariationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VariationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVariationSubscription>() => T;
}

export interface RefreshTokenListSubscriptionPayload {
  mutation: MutationType;
  node: RefreshTokenList;
  updatedFields: String[];
  previousValues: RefreshTokenListPreviousValues;
}

export interface RefreshTokenListSubscriptionPayloadPromise
  extends Promise<RefreshTokenListSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RefreshTokenListPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RefreshTokenListPreviousValuesPromise>() => T;
}

export interface RefreshTokenListSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RefreshTokenListSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RefreshTokenListSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RefreshTokenListPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface RefreshTokenListPreviousValues {
  userId: ID_Output;
  refreshToken: String;
}

export interface RefreshTokenListPreviousValuesPromise
  extends Promise<RefreshTokenListPreviousValues>,
    Fragmentable {
  userId: () => Promise<ID_Output>;
  refreshToken: () => Promise<String>;
}

export interface RefreshTokenListPreviousValuesSubscription
  extends Promise<AsyncIterator<RefreshTokenListPreviousValues>>,
    Fragmentable {
  userId: () => Promise<AsyncIterator<ID_Output>>;
  refreshToken: () => Promise<AsyncIterator<String>>;
}

export interface TestSessionConnection {
  pageInfo: PageInfo;
  edges: TestSessionEdge[];
}

export interface TestSessionConnectionPromise
  extends Promise<TestSessionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TestSessionEdge>>() => T;
  aggregate: <T = AggregateTestSessionPromise>() => T;
}

export interface TestSessionConnectionSubscription
  extends Promise<AsyncIterator<TestSessionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TestSessionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTestSessionSubscription>() => T;
}

export interface AggregateRefreshTokenList {
  count: Int;
}

export interface AggregateRefreshTokenListPromise
  extends Promise<AggregateRefreshTokenList>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRefreshTokenListSubscription
  extends Promise<AsyncIterator<AggregateRefreshTokenList>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestSession {
  id: ID_Output;
  createdAt: DateTimeOutput;
  diffImageKey?: String;
  imageKey?: String;
  misMatchPercentage?: Float;
  misMatchTolerance: Float;
  isSameDimensions?: Boolean;
  updatedAt: DateTimeOutput;
  state: TestSessionState;
  stateComment?: String;
  autoBaseline: Boolean;
}

export interface TestSessionPromise extends Promise<TestSession>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  diffImageKey: () => Promise<String>;
  imageKey: () => Promise<String>;
  misMatchPercentage: () => Promise<Float>;
  misMatchTolerance: () => Promise<Float>;
  isSameDimensions: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  variation: <T = VariationPromise>() => T;
  baselineForDiffRef: <T = TestSessionPromise>() => T;
  baselineRef: <T = VariationPromise>() => T;
  diffBaseline: <T = TestSessionPromise>() => T;
  state: () => Promise<TestSessionState>;
  stateChangedByUser: <T = UserPromise>() => T;
  stateComment: () => Promise<String>;
  autoBaseline: () => Promise<Boolean>;
}

export interface TestSessionSubscription
  extends Promise<AsyncIterator<TestSession>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  diffImageKey: () => Promise<AsyncIterator<String>>;
  imageKey: () => Promise<AsyncIterator<String>>;
  misMatchPercentage: () => Promise<AsyncIterator<Float>>;
  misMatchTolerance: () => Promise<AsyncIterator<Float>>;
  isSameDimensions: () => Promise<AsyncIterator<Boolean>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  variation: <T = VariationSubscription>() => T;
  baselineForDiffRef: <T = TestSessionSubscription>() => T;
  baselineRef: <T = VariationSubscription>() => T;
  diffBaseline: <T = TestSessionSubscription>() => T;
  state: () => Promise<AsyncIterator<TestSessionState>>;
  stateChangedByUser: <T = UserSubscription>() => T;
  stateComment: () => Promise<AsyncIterator<String>>;
  autoBaseline: () => Promise<AsyncIterator<Boolean>>;
}

export interface TestSessionNullablePromise
  extends Promise<TestSession | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  diffImageKey: () => Promise<String>;
  imageKey: () => Promise<String>;
  misMatchPercentage: () => Promise<Float>;
  misMatchTolerance: () => Promise<Float>;
  isSameDimensions: () => Promise<Boolean>;
  updatedAt: () => Promise<DateTimeOutput>;
  variation: <T = VariationPromise>() => T;
  baselineForDiffRef: <T = TestSessionPromise>() => T;
  baselineRef: <T = VariationPromise>() => T;
  diffBaseline: <T = TestSessionPromise>() => T;
  state: () => Promise<TestSessionState>;
  stateChangedByUser: <T = UserPromise>() => T;
  stateComment: () => Promise<String>;
  autoBaseline: () => Promise<Boolean>;
}

export interface TestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  name: String;
  updatedAt: DateTimeOutput;
}

export interface TestPreviousValuesPromise
  extends Promise<TestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface TestPreviousValuesSubscription
  extends Promise<AsyncIterator<TestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TestSubscriptionPayload {
  mutation: MutationType;
  node: Test;
  updatedFields: String[];
  previousValues: TestPreviousValues;
}

export interface TestSubscriptionPayloadPromise
  extends Promise<TestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TestPreviousValuesPromise>() => T;
}

export interface TestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TestPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  lastname?: String;
  phoneNumber?: String;
  forename?: String;
  active: Boolean;
  role: Role;
  apiKey: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lastname: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  forename: () => Promise<String>;
  active: () => Promise<Boolean>;
  role: () => Promise<Role>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  apiKey: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastname: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  forename: () => Promise<AsyncIterator<String>>;
  active: () => Promise<AsyncIterator<Boolean>>;
  role: () => Promise<AsyncIterator<Role>>;
  projects: <T = Promise<AsyncIterator<ProjectSubscription>>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  apiKey: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  lastname: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  forename: () => Promise<String>;
  active: () => Promise<Boolean>;
  role: () => Promise<Role>;
  projects: <T = FragmentableArray<Project>>(args?: {
    where?: ProjectWhereInput;
    orderBy?: ProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  apiKey: () => Promise<String>;
}

export interface AggregateVariation {
  count: Int;
}

export interface AggregateVariationPromise
  extends Promise<AggregateVariation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVariationSubscription
  extends Promise<AsyncIterator<AggregateVariation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TestEdge {
  node: Test;
  cursor: String;
}

export interface TestEdgePromise extends Promise<TestEdge>, Fragmentable {
  node: <T = TestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TestEdgeSubscription
  extends Promise<AsyncIterator<TestEdge>>,
    Fragmentable {
  node: <T = TestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTestSession {
  count: Int;
}

export interface AggregateTestSessionPromise
  extends Promise<AggregateTestSession>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTestSessionSubscription
  extends Promise<AsyncIterator<AggregateTestSession>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Json = any;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "RefreshTokenList",
    embedded: false
  },
  {
    name: "Project",
    embedded: false
  },
  {
    name: "Test",
    embedded: false
  },
  {
    name: "TestSession",
    embedded: false
  },
  {
    name: "Variation",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "TestSessionState",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
